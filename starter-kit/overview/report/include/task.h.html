
<html>
<head>
<title>include/task.h</title>
<link rel="stylesheet" type="text/css" href="../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 /*</div><div id="2" class="line none">    2  * FreeRTOS Kernel &lt;DEVELOPMENT BRANCH&gt;</div><div id="3" class="line none">    3  * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.</div><div id="4" class="line none">    4  *</div><div id="5" class="line none">    5  * SPDX-License-Identifier: MIT</div><div id="6" class="line none">    6  *</div><div id="7" class="line none">    7  * Permission is hereby granted, free of charge, to any person obtaining a copy of</div><div id="8" class="line none">    8  * this software and associated documentation files (the "Software"), to deal in</div><div id="9" class="line none">    9  * the Software without restriction, including without limitation the rights to</div><div id="10" class="line none">   10  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of</div><div id="11" class="line none">   11  * the Software, and to permit persons to whom the Software is furnished to do so,</div><div id="12" class="line none">   12  * subject to the following conditions:</div><div id="13" class="line none">   13  *</div><div id="14" class="line none">   14  * The above copyright notice and this permission notice shall be included in all</div><div id="15" class="line none">   15  * copies or substantial portions of the Software.</div><div id="16" class="line none">   16  *</div><div id="17" class="line none">   17  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</div><div id="18" class="line none">   18  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS</div><div id="19" class="line none">   19  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR</div><div id="20" class="line none">   20  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER</div><div id="21" class="line none">   21  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</div><div id="22" class="line none">   22  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</div><div id="23" class="line none">   23  *</div><div id="24" class="line none">   24  * https://www.FreeRTOS.org</div><div id="25" class="line none">   25  * https://github.com/FreeRTOS</div><div id="26" class="line none">   26  *</div><div id="27" class="line none">   27  */</div><div id="28" class="line none">   28 </div><div id="29" class="line none">   29 </div><div id="30" class="line none">   30 #ifndef <a href="task.h.html#31">INC_TASK_H</a></div><div id="31" class="line none">   31 #define <a href="task.h.html#31">INC_TASK_H</a></div><div id="32" class="line none">   32 </div><div id="33" class="line none">   33 #ifndef INC_FREERTOS_H</div><div id="34" class="line none">   34     #error "include FreeRTOS.h must appear in source files before include task.h"</div><div id="35" class="line none">   35 #endif</div><div id="36" class="line none">   36 </div><div id="37" class="line none">   37 #include "list.h"</div><div id="38" class="line none">   38 </div><div id="39" class="line none">   39 /* *INDENT-OFF* */</div><div id="40" class="line none">   40 #ifdef __cplusplus</div><div id="41" class="line none">   41     extern "C" {</div><div id="42" class="line none">   42 #endif</div><div id="43" class="line none">   43 /* *INDENT-ON* */</div><div id="44" class="line none">   44 </div><div id="45" class="line none">   45 /*-----------------------------------------------------------</div><div id="46" class="line none">   46 * MACROS AND DEFINITIONS</div><div id="47" class="line none">   47 *----------------------------------------------------------*/</div><div id="48" class="line none">   48 </div><div id="49" class="line none">   49 /*</div><div id="50" class="line none">   50  * If tskKERNEL_VERSION_NUMBER ends with + it represents the version in development</div><div id="51" class="line none">   51  * after the numbered release.</div><div id="52" class="line none">   52  *</div><div id="53" class="line none">   53  * The tskKERNEL_VERSION_MAJOR, tskKERNEL_VERSION_MINOR, tskKERNEL_VERSION_BUILD</div><div id="54" class="line none">   54  * values will reflect the last released version number.</div><div id="55" class="line none">   55  */</div><div id="56" class="line none">   56 #define <a href="task.h.html#56">tskKERNEL_VERSION_NUMBER</a>       "V10.4.4+"</div><div id="57" class="line none">   57 #define <a href="task.h.html#57">tskKERNEL_VERSION_MAJOR</a>        10</div><div id="58" class="line none">   58 #define <a href="task.h.html#58">tskKERNEL_VERSION_MINOR</a>        4</div><div id="59" class="line none">   59 #define <a href="task.h.html#59">tskKERNEL_VERSION_BUILD</a>        4</div><div id="60" class="line none">   60 </div><div id="61" class="line none">   61 /* MPU region parameters passed in ulParameters</div><div id="62" class="line none">   62  * of MemoryRegion_t struct. */</div><div id="63" class="line none">   63 #define <a href="task.h.html#63">tskMPU_REGION_READ_ONLY</a>        ( 1UL &lt;&lt; 0UL )</div><div id="64" class="line none">   64 #define <a href="task.h.html#64">tskMPU_REGION_READ_WRITE</a>       ( 1UL &lt;&lt; 1UL )</div><div id="65" class="line none">   65 #define <a href="task.h.html#65">tskMPU_REGION_EXECUTE_NEVER</a>    ( 1UL &lt;&lt; 2UL )</div><div id="66" class="line none">   66 #define <a href="task.h.html#66">tskMPU_REGION_NORMAL_MEMORY</a>    ( 1UL &lt;&lt; 3UL )</div><div id="67" class="line none">   67 #define <a href="task.h.html#67">tskMPU_REGION_DEVICE_MEMORY</a>    ( 1UL &lt;&lt; 4UL )</div><div id="68" class="line none">   68 </div><div id="69" class="line none">   69 /* The direct to task notification feature used to have only a single notification</div><div id="70" class="line none">   70  * per task.  Now there is an array of notifications per task that is dimensioned by</div><div id="71" class="line none">   71  * configTASK_NOTIFICATION_ARRAY_ENTRIES.  For backward compatibility, any use of the</div><div id="72" class="line none">   72  * original direct to task notification defaults to using the first index in the</div><div id="73" class="line none">   73  * array. */</div><div id="74" class="line none">   74 #define <a href="task.h.html#74">tskDEFAULT_INDEX_TO_NOTIFY</a>     ( 0 )</div><div id="75" class="line none">   75 </div><div id="76" class="line none">   76 /**</div><div id="77" class="line none">   77  * task. h</div><div id="78" class="line none">   78  *</div><div id="79" class="line none">   79  * Type by which tasks are referenced.  For example, a call to xTaskCreate</div><div id="80" class="line none">   80  * returns (via a pointer parameter) an TaskHandle_t variable that can then</div><div id="81" class="line none">   81  * be used as a parameter to vTaskDelete to delete the task.</div><div id="82" class="line none">   82  *</div><div id="83" class="line none">   83  * \defgroup TaskHandle_t TaskHandle_t</div><div id="84" class="line none">   84  * \ingroup Tasks</div><div id="85" class="line none">   85  */</div><div id="86" class="line none">   86 struct tskTaskControlBlock; /* The old naming convention is used to prevent breaking kernel aware debuggers. */</div><div id="87" class="line none">   87 typedef struct tskTaskControlBlock * <a href="task.h.html#87">TaskHandle_t</a>;</div><div id="88" class="line none">   88 </div><div id="89" class="line none">   89 /*</div><div id="90" class="line none">   90  * Defines the prototype to which the application task hook function must</div><div id="91" class="line none">   91  * conform.</div><div id="92" class="line none">   92  */</div><div id="93" class="line none">   93 typedef <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> (* <a href="task.h.html#93">TaskHookFunction_t</a>)( void * );</div><div id="94" class="line none">   94 </div><div id="95" class="line none">   95 /* Task states returned by eTaskGetState. */</div><div id="96" class="line none">   96 typedef enum</div><div id="97" class="line none">   97 {</div><div id="98" class="line none">   98     <a href="task.h.html#98">eRunning</a> = 0, /* A task is querying the state of itself, so must be running. */</div><div id="99" class="line none">   99     <a href="task.h.html#99">eReady</a>,       /* The task being queried is in a ready or pending ready list. */</div><div id="100" class="line none">  100     <a href="task.h.html#100">eBlocked</a>,     /* The task being queried is in the Blocked state. */</div><div id="101" class="line none">  101     <a href="task.h.html#101">eSuspended</a>,   /* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */</div><div id="102" class="line none">  102     <a href="task.h.html#102">eDeleted</a>,     /* The task being queried has been deleted, but its TCB has not yet been freed. */</div><div id="103" class="line none">  103     <a href="task.h.html#103">eInvalid</a>      /* Used as an 'invalid state' value. */</div><div id="104" class="line none">  104 } <a href="task.h.html#104">eTaskState</a>;</div><div id="105" class="line none">  105 </div><div id="106" class="line none">  106 /* Actions that can be performed when vTaskNotify() is called. */</div><div id="107" class="line none">  107 typedef enum</div><div id="108" class="line none">  108 {</div><div id="109" class="line none">  109     <a href="task.h.html#109">eNoAction</a> = 0,            /* Notify the task without updating its notify value. */</div><div id="110" class="line none">  110     <a href="task.h.html#110">eSetBits</a>,                 /* Set bits in the task's notification value. */</div><div id="111" class="line none">  111     <a href="task.h.html#111">eIncrement</a>,               /* Increment the task's notification value. */</div><div id="112" class="line none">  112     <a href="task.h.html#112">eSetValueWithOverwrite</a>,   /* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */</div><div id="113" class="line none">  113     <a href="task.h.html#113">eSetValueWithoutOverwrite</a> /* Set the task's notification value if the previous value has been read by the task. */</div><div id="114" class="line none">  114 } <a href="task.h.html#114">eNotifyAction</a>;</div><div id="115" class="line none">  115 </div><div id="116" class="line none">  116 /*</div><div id="117" class="line none">  117  * Used internally only.</div><div id="118" class="line none">  118  */</div><div id="119" class="line none">  119 typedef struct <a href="task.h.html#119">xTIME_OUT</a></div><div id="120" class="line none">  120 {</div><div id="121" class="line none">  121     <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> <a href="task.h.html#121">xOverflowCount</a>;</div><div id="122" class="line none">  122     <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> <a href="task.h.html#122">xTimeOnEntering</a>;</div><div id="123" class="line none">  123 } <a href="task.h.html#123">TimeOut_t</a>;</div><div id="124" class="line none">  124 </div><div id="125" class="line none">  125 /*</div><div id="126" class="line none">  126  * Defines the memory ranges allocated to the task when an MPU is used.</div><div id="127" class="line none">  127  */</div><div id="128" class="line none">  128 typedef struct <a href="task.h.html#128">xMEMORY_REGION</a></div><div id="129" class="line none">  129 {</div><div id="130" class="line none">  130     void * <a href="task.h.html#130">pvBaseAddress</a>;</div><div id="131" class="line none">  131     uint32_t <a href="task.h.html#131">ulLengthInBytes</a>;</div><div id="132" class="line none">  132     uint32_t <a href="task.h.html#132">ulParameters</a>;</div><div id="133" class="line none">  133 } <a href="task.h.html#133">MemoryRegion_t</a>;</div><div id="134" class="line none">  134 </div><div id="135" class="line none">  135 /*</div><div id="136" class="line none">  136  * Parameters required to create an MPU protected task.</div><div id="137" class="line none">  137  */</div><div id="138" class="line none">  138 typedef struct <a href="task.h.html#138">xTASK_PARAMETERS</a></div><div id="139" class="line none">  139 {</div><div id="140" class="line none">  140     TaskFunction_t <a href="task.h.html#140">pvTaskCode</a>;</div><div id="141" class="line none">  141     const char * <a href="task.h.html#141">pcName</a>; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */</div><div id="142" class="line none">  142     configSTACK_DEPTH_TYPE <a href="task.h.html#142">usStackDepth</a>;</div><div id="143" class="line none">  143     void * <a href="task.h.html#143">pvParameters</a>;</div><div id="144" class="line none">  144     <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> <a href="task.h.html#144">uxPriority</a>;</div><div id="145" class="line none">  145     <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#59">StackType_t</a> * <a href="task.h.html#145">puxStackBuffer</a>;</div><div id="146" class="line none">  146     <a href="task.h.html#133">MemoryRegion_t</a> <a href="task.h.html#146">xRegions</a>[ <a href="portable.h.html#77">portNUM_CONFIGURABLE_REGIONS</a> ];</div><div id="147" class="line none">  147     #if ( ( <a href="portable.h.html#73">portUSING_MPU_WRAPPERS</a> == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )</div><div id="148" class="line none">  148         StaticTask_t * const <a href="task.h.html#148">pxTaskBuffer</a>;</div><div id="149" class="line none">  149     #endif</div><div id="150" class="line none">  150 } <a href="task.h.html#150">TaskParameters_t</a>;</div><div id="151" class="line none">  151 </div><div id="152" class="line none">  152 /* Used with the uxTaskGetSystemState() function to return the state of each task</div><div id="153" class="line none">  153  * in the system. */</div><div id="154" class="line none">  154 typedef struct <a href="task.h.html#154">xTASK_STATUS</a></div><div id="155" class="line none">  155 {</div><div id="156" class="line none">  156     <a href="task.h.html#87">TaskHandle_t</a> <a href="task.h.html#156">xHandle</a>;                         /* The handle of the task to which the rest of the information in the structure relates. */</div><div id="157" class="line none">  157     const char * <a href="task.h.html#157">pcTaskName</a>;                      /* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */</div><div id="158" class="line none">  158     <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> <a href="task.h.html#158">xTaskNumber</a>;                      /* A number unique to the task. */</div><div id="159" class="line none">  159     <a href="task.h.html#104">eTaskState</a> <a href="task.h.html#159">eCurrentState</a>;                     /* The state in which the task existed when the structure was populated. */</div><div id="160" class="line none">  160     <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> <a href="task.h.html#160">uxCurrentPriority</a>;                /* The priority at which the task was running (may be inherited) when the structure was populated. */</div><div id="161" class="line none">  161     <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> <a href="task.h.html#161">uxBasePriority</a>;                   /* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */</div><div id="162" class="line none">  162     configRUN_TIME_COUNTER_TYPE <a href="task.h.html#162">ulRunTimeCounter</a>; /* The total run time allocated to the task so far, as defined by the run time stats clock.  See https://www.FreeRTOS.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */</div><div id="163" class="line none">  163     <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#59">StackType_t</a> * <a href="task.h.html#163">pxStackBase</a>;                    /* Points to the lowest address of the task's stack area. */</div><div id="164" class="line none">  164     #if ( ( <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#71">portSTACK_GROWTH</a> &gt; 0 ) &amp;&amp; ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )</div><div id="165" class="line none">  165         <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#59">StackType_t</a> * <a href="task.h.html#165">pxTopOfStack</a>;               /* Points to the top address of the task's stack area. */</div><div id="166" class="line none">  166         <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#59">StackType_t</a> * <a href="task.h.html#166">pxEndOfStack</a>;               /* Points to the end address of the task's stack area. */</div><div id="167" class="line none">  167     #endif</div><div id="168" class="line none">  168     configSTACK_DEPTH_TYPE <a href="task.h.html#168">usStackHighWaterMark</a>;  /* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */</div><div id="169" class="line none">  169 } <a href="task.h.html#169">TaskStatus_t</a>;</div><div id="170" class="line none">  170 </div><div id="171" class="line none">  171 /* Possible return values for eTaskConfirmSleepModeStatus(). */</div><div id="172" class="line none">  172 typedef enum</div><div id="173" class="line none">  173 {</div><div id="174" class="line none">  174     <a href="task.h.html#174">eAbortSleep</a> = 0,           /* A task has been made ready or a context switch pended since portSUPPRESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */</div><div id="175" class="line none">  175     <a href="task.h.html#175">eStandardSleep</a>,            /* Enter a sleep mode that will not last any longer than the expected idle time. */</div><div id="176" class="line none">  176     #if ( INCLUDE_vTaskSuspend == 1 )</div><div id="177" class="line none">  177         <a href="task.h.html#177">eNoTasksWaitingTimeout</a> /* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */</div><div id="178" class="line none">  178     #endif /* INCLUDE_vTaskSuspend */</div><div id="179" class="line none">  179 } <a href="task.h.html#179">eSleepModeStatus</a>;</div><div id="180" class="line none">  180 </div><div id="181" class="line none">  181 /**</div><div id="182" class="line none">  182  * Defines the priority used by the idle task.  This must not be modified.</div><div id="183" class="line none">  183  *</div><div id="184" class="line none">  184  * \ingroup TaskUtils</div><div id="185" class="line none">  185  */</div><div id="186" class="line none">  186 #define <a href="task.h.html#186">tskIDLE_PRIORITY</a>    ( ( <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> ) 0U )</div><div id="187" class="line none">  187 </div><div id="188" class="line none">  188 /**</div><div id="189" class="line none">  189  * task. h</div><div id="190" class="line none">  190  *</div><div id="191" class="line none">  191  * Macro for forcing a context switch.</div><div id="192" class="line none">  192  *</div><div id="193" class="line none">  193  * \defgroup taskYIELD taskYIELD</div><div id="194" class="line none">  194  * \ingroup SchedulerControl</div><div id="195" class="line none">  195  */</div><div id="196" class="line none">  196 #define <a href="task.h.html#196">taskYIELD</a>()                        <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#81">portYIELD</a>()</div><div id="197" class="line none">  197 </div><div id="198" class="line none">  198 /**</div><div id="199" class="line none">  199  * task. h</div><div id="200" class="line none">  200  *</div><div id="201" class="line none">  201  * Macro to mark the start of a critical code region.  Preemptive context</div><div id="202" class="line none">  202  * switches cannot occur when in a critical region.</div><div id="203" class="line none">  203  *</div><div id="204" class="line none">  204  * NOTE: This may alter the stack (depending on the portable implementation)</div><div id="205" class="line none">  205  * so must be used with care!</div><div id="206" class="line none">  206  *</div><div id="207" class="line none">  207  * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL</div><div id="208" class="line none">  208  * \ingroup SchedulerControl</div><div id="209" class="line none">  209  */</div><div id="210" class="line none">  210 #define <a href="task.h.html#210">taskENTER_CRITICAL</a>()               <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#102">portENTER_CRITICAL</a>()</div><div id="211" class="line none">  211 #define <a href="task.h.html#211">taskENTER_CRITICAL_FROM_ISR</a>()      <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#98">portSET_INTERRUPT_MASK_FROM_ISR</a>()</div><div id="212" class="line none">  212 </div><div id="213" class="line none">  213 /**</div><div id="214" class="line none">  214  * task. h</div><div id="215" class="line none">  215  *</div><div id="216" class="line none">  216  * Macro to mark the end of a critical code region.  Preemptive context</div><div id="217" class="line none">  217  * switches cannot occur when in a critical region.</div><div id="218" class="line none">  218  *</div><div id="219" class="line none">  219  * NOTE: This may alter the stack (depending on the portable implementation)</div><div id="220" class="line none">  220  * so must be used with care!</div><div id="221" class="line none">  221  *</div><div id="222" class="line none">  222  * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL</div><div id="223" class="line none">  223  * \ingroup SchedulerControl</div><div id="224" class="line none">  224  */</div><div id="225" class="line none">  225 #define <a href="task.h.html#225">taskEXIT_CRITICAL</a>()                <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#103">portEXIT_CRITICAL</a>()</div><div id="226" class="line none">  226 #define <a href="task.h.html#226">taskEXIT_CRITICAL_FROM_ISR</a>( x )    <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#99">portCLEAR_INTERRUPT_MASK_FROM_ISR</a>( x )</div><div id="227" class="line none">  227 </div><div id="228" class="line none">  228 /**</div><div id="229" class="line none">  229  * task. h</div><div id="230" class="line none">  230  *</div><div id="231" class="line none">  231  * Macro to disable all maskable interrupts.</div><div id="232" class="line none">  232  *</div><div id="233" class="line none">  233  * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS</div><div id="234" class="line none">  234  * \ingroup SchedulerControl</div><div id="235" class="line none">  235  */</div><div id="236" class="line none">  236 #define <a href="task.h.html#236">taskDISABLE_INTERRUPTS</a>()           <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#100">portDISABLE_INTERRUPTS</a>()</div><div id="237" class="line none">  237 </div><div id="238" class="line none">  238 /**</div><div id="239" class="line none">  239  * task. h</div><div id="240" class="line none">  240  *</div><div id="241" class="line none">  241  * Macro to enable microcontroller interrupts.</div><div id="242" class="line none">  242  *</div><div id="243" class="line none">  243  * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS</div><div id="244" class="line none">  244  * \ingroup SchedulerControl</div><div id="245" class="line none">  245  */</div><div id="246" class="line none">  246 #define <a href="task.h.html#246">taskENABLE_INTERRUPTS</a>()            <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#101">portENABLE_INTERRUPTS</a>()</div><div id="247" class="line none">  247 </div><div id="248" class="line none">  248 /* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is</div><div id="249" class="line none">  249  * 0 to generate more optimal code when configASSERT() is defined as the constant</div><div id="250" class="line none">  250  * is used in assert() statements. */</div><div id="251" class="line none">  251 #define <a href="task.h.html#251">taskSCHEDULER_SUSPENDED</a>      ( ( <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> ) 0 )</div><div id="252" class="line none">  252 #define <a href="task.h.html#252">taskSCHEDULER_NOT_STARTED</a>    ( ( <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> ) 1 )</div><div id="253" class="line none">  253 #define <a href="task.h.html#253">taskSCHEDULER_RUNNING</a>        ( ( <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> ) 2 )</div><div id="254" class="line none">  254 </div><div id="255" class="line none">  255 </div><div id="256" class="line none">  256 /*-----------------------------------------------------------</div><div id="257" class="line none">  257 * TASK CREATION API</div><div id="258" class="line none">  258 *----------------------------------------------------------*/</div><div id="259" class="line none">  259 </div><div id="260" class="line none">  260 /**</div><div id="261" class="line none">  261  * task. h</div><div id="262" class="line none">  262  * @code{c}</div><div id="263" class="line none">  263  * BaseType_t xTaskCreate(</div><div id="264" class="line none">  264  *                            TaskFunction_t pxTaskCode,</div><div id="265" class="line none">  265  *                            const char *pcName,</div><div id="266" class="line none">  266  *                            configSTACK_DEPTH_TYPE usStackDepth,</div><div id="267" class="line none">  267  *                            void *pvParameters,</div><div id="268" class="line none">  268  *                            UBaseType_t uxPriority,</div><div id="269" class="line none">  269  *                            TaskHandle_t *pxCreatedTask</div><div id="270" class="line none">  270  *                        );</div><div id="271" class="line none">  271  * @endcode</div><div id="272" class="line none">  272  *</div><div id="273" class="line none">  273  * Create a new task and add it to the list of tasks that are ready to run.</div><div id="274" class="line none">  274  *</div><div id="275" class="line none">  275  * Internally, within the FreeRTOS implementation, tasks use two blocks of</div><div id="276" class="line none">  276  * memory.  The first block is used to hold the task's data structures.  The</div><div id="277" class="line none">  277  * second block is used by the task as its stack.  If a task is created using</div><div id="278" class="line none">  278  * xTaskCreate() then both blocks of memory are automatically dynamically</div><div id="279" class="line none">  279  * allocated inside the xTaskCreate() function.  (see</div><div id="280" class="line none">  280  * https://www.FreeRTOS.org/a00111.html).  If a task is created using</div><div id="281" class="line none">  281  * xTaskCreateStatic() then the application writer must provide the required</div><div id="282" class="line none">  282  * memory.  xTaskCreateStatic() therefore allows a task to be created without</div><div id="283" class="line none">  283  * using any dynamic memory allocation.</div><div id="284" class="line none">  284  *</div><div id="285" class="line none">  285  * See xTaskCreateStatic() for a version that does not use any dynamic memory</div><div id="286" class="line none">  286  * allocation.</div><div id="287" class="line none">  287  *</div><div id="288" class="line none">  288  * xTaskCreate() can only be used to create a task that has unrestricted</div><div id="289" class="line none">  289  * access to the entire microcontroller memory map.  Systems that include MPU</div><div id="290" class="line none">  290  * support can alternatively create an MPU constrained task using</div><div id="291" class="line none">  291  * xTaskCreateRestricted().</div><div id="292" class="line none">  292  *</div><div id="293" class="line none">  293  * @param pxTaskCode Pointer to the task entry function.  Tasks</div><div id="294" class="line none">  294  * must be implemented to never return (i.e. continuous loop).</div><div id="295" class="line none">  295  *</div><div id="296" class="line none">  296  * @param pcName A descriptive name for the task.  This is mainly used to</div><div id="297" class="line none">  297  * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default</div><div id="298" class="line none">  298  * is 16.</div><div id="299" class="line none">  299  *</div><div id="300" class="line none">  300  * @param usStackDepth The size of the task stack specified as the number of</div><div id="301" class="line none">  301  * variables the stack can hold - not the number of bytes.  For example, if</div><div id="302" class="line none">  302  * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes</div><div id="303" class="line none">  303  * will be allocated for stack storage.</div><div id="304" class="line none">  304  *</div><div id="305" class="line none">  305  * @param pvParameters Pointer that will be used as the parameter for the task</div><div id="306" class="line none">  306  * being created.</div><div id="307" class="line none">  307  *</div><div id="308" class="line none">  308  * @param uxPriority The priority at which the task should run.  Systems that</div><div id="309" class="line none">  309  * include MPU support can optionally create tasks in a privileged (system)</div><div id="310" class="line none">  310  * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For</div><div id="311" class="line none">  311  * example, to create a privileged task at priority 2 the uxPriority parameter</div><div id="312" class="line none">  312  * should be set to ( 2 | portPRIVILEGE_BIT ).</div><div id="313" class="line none">  313  *</div><div id="314" class="line none">  314  * @param pxCreatedTask Used to pass back a handle by which the created task</div><div id="315" class="line none">  315  * can be referenced.</div><div id="316" class="line none">  316  *</div><div id="317" class="line none">  317  * @return pdPASS if the task was successfully created and added to a ready</div><div id="318" class="line none">  318  * list, otherwise an error code defined in the file projdefs.h</div><div id="319" class="line none">  319  *</div><div id="320" class="line none">  320  * Example usage:</div><div id="321" class="line none">  321  * @code{c}</div><div id="322" class="line none">  322  * // Task to be created.</div><div id="323" class="line none">  323  * void vTaskCode( void * pvParameters )</div><div id="324" class="line none">  324  * {</div><div id="325" class="line none">  325  *   for( ;; )</div><div id="326" class="line none">  326  *   {</div><div id="327" class="line none">  327  *       // Task code goes here.</div><div id="328" class="line none">  328  *   }</div><div id="329" class="line none">  329  * }</div><div id="330" class="line none">  330  *</div><div id="331" class="line none">  331  * // Function that creates a task.</div><div id="332" class="line none">  332  * void vOtherFunction( void )</div><div id="333" class="line none">  333  * {</div><div id="334" class="line none">  334  * static uint8_t ucParameterToPass;</div><div id="335" class="line none">  335  * TaskHandle_t xHandle = NULL;</div><div id="336" class="line none">  336  *</div><div id="337" class="line none">  337  *   // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass</div><div id="338" class="line none">  338  *   // must exist for the lifetime of the task, so in this case is declared static.  If it was just an</div><div id="339" class="line none">  339  *   // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time</div><div id="340" class="line none">  340  *   // the new task attempts to access it.</div><div id="341" class="line none">  341  *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &amp;ucParameterToPass, tskIDLE_PRIORITY, &amp;xHandle );</div><div id="342" class="line none">  342  *   configASSERT( xHandle );</div><div id="343" class="line none">  343  *</div><div id="344" class="line none">  344  *   // Use the handle to delete the task.</div><div id="345" class="line none">  345  *   if( xHandle != NULL )</div><div id="346" class="line none">  346  *   {</div><div id="347" class="line none">  347  *      vTaskDelete( xHandle );</div><div id="348" class="line none">  348  *   }</div><div id="349" class="line none">  349  * }</div><div id="350" class="line none">  350  * @endcode</div><div id="351" class="line none">  351  * \defgroup xTaskCreate xTaskCreate</div><div id="352" class="line none">  352  * \ingroup Tasks</div><div id="353" class="line none">  353  */</div><div id="354" class="line none">  354 #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</div><div id="355" class="line none">  355     <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskCreate( TaskFunction_t pxTaskCode,</div><div id="356" class="line none">  356                             const char * const <a href="task.h.html#141">pcName</a>, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */</div><div id="357" class="line none">  357                             const configSTACK_DEPTH_TYPE <a href="task.h.html#142">usStackDepth</a>,</div><div id="358" class="line none">  358                             void * const <a href="task.h.html#143">pvParameters</a>,</div><div id="359" class="line none">  359                             <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> <a href="task.h.html#144">uxPriority</a>,</div><div id="360" class="line none">  360                             <a href="task.h.html#87">TaskHandle_t</a> * const pxCreatedTask ) PRIVILEGED_FUNCTION;</div><div id="361" class="line none">  361 #endif</div><div id="362" class="line none">  362 </div><div id="363" class="line none">  363 /**</div><div id="364" class="line none">  364  * task. h</div><div id="365" class="line none">  365  * @code{c}</div><div id="366" class="line none">  366  * TaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode,</div><div id="367" class="line none">  367  *                               const char *pcName,</div><div id="368" class="line none">  368  *                               uint32_t ulStackDepth,</div><div id="369" class="line none">  369  *                               void *pvParameters,</div><div id="370" class="line none">  370  *                               UBaseType_t uxPriority,</div><div id="371" class="line none">  371  *                               StackType_t *puxStackBuffer,</div><div id="372" class="line none">  372  *                               StaticTask_t *pxTaskBuffer );</div><div id="373" class="line none">  373  * @endcode</div><div id="374" class="line none">  374  *</div><div id="375" class="line none">  375  * Create a new task and add it to the list of tasks that are ready to run.</div><div id="376" class="line none">  376  *</div><div id="377" class="line none">  377  * Internally, within the FreeRTOS implementation, tasks use two blocks of</div><div id="378" class="line none">  378  * memory.  The first block is used to hold the task's data structures.  The</div><div id="379" class="line none">  379  * second block is used by the task as its stack.  If a task is created using</div><div id="380" class="line none">  380  * xTaskCreate() then both blocks of memory are automatically dynamically</div><div id="381" class="line none">  381  * allocated inside the xTaskCreate() function.  (see</div><div id="382" class="line none">  382  * https://www.FreeRTOS.org/a00111.html).  If a task is created using</div><div id="383" class="line none">  383  * xTaskCreateStatic() then the application writer must provide the required</div><div id="384" class="line none">  384  * memory.  xTaskCreateStatic() therefore allows a task to be created without</div><div id="385" class="line none">  385  * using any dynamic memory allocation.</div><div id="386" class="line none">  386  *</div><div id="387" class="line none">  387  * @param pxTaskCode Pointer to the task entry function.  Tasks</div><div id="388" class="line none">  388  * must be implemented to never return (i.e. continuous loop).</div><div id="389" class="line none">  389  *</div><div id="390" class="line none">  390  * @param pcName A descriptive name for the task.  This is mainly used to</div><div id="391" class="line none">  391  * facilitate debugging.  The maximum length of the string is defined by</div><div id="392" class="line none">  392  * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.</div><div id="393" class="line none">  393  *</div><div id="394" class="line none">  394  * @param ulStackDepth The size of the task stack specified as the number of</div><div id="395" class="line none">  395  * variables the stack can hold - not the number of bytes.  For example, if</div><div id="396" class="line none">  396  * the stack is 32-bits wide and ulStackDepth is defined as 100 then 400 bytes</div><div id="397" class="line none">  397  * will be allocated for stack storage.</div><div id="398" class="line none">  398  *</div><div id="399" class="line none">  399  * @param pvParameters Pointer that will be used as the parameter for the task</div><div id="400" class="line none">  400  * being created.</div><div id="401" class="line none">  401  *</div><div id="402" class="line none">  402  * @param uxPriority The priority at which the task will run.</div><div id="403" class="line none">  403  *</div><div id="404" class="line none">  404  * @param puxStackBuffer Must point to a StackType_t array that has at least</div><div id="405" class="line none">  405  * ulStackDepth indexes - the array will then be used as the task's stack,</div><div id="406" class="line none">  406  * removing the need for the stack to be allocated dynamically.</div><div id="407" class="line none">  407  *</div><div id="408" class="line none">  408  * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will</div><div id="409" class="line none">  409  * then be used to hold the task's data structures, removing the need for the</div><div id="410" class="line none">  410  * memory to be allocated dynamically.</div><div id="411" class="line none">  411  *</div><div id="412" class="line none">  412  * @return If neither puxStackBuffer nor pxTaskBuffer are NULL, then the task</div><div id="413" class="line none">  413  * will be created and a handle to the created task is returned.  If either</div><div id="414" class="line none">  414  * puxStackBuffer or pxTaskBuffer are NULL then the task will not be created and</div><div id="415" class="line none">  415  * NULL is returned.</div><div id="416" class="line none">  416  *</div><div id="417" class="line none">  417  * Example usage:</div><div id="418" class="line none">  418  * @code{c}</div><div id="419" class="line none">  419  *</div><div id="420" class="line none">  420  *  // Dimensions of the buffer that the task being created will use as its stack.</div><div id="421" class="line none">  421  *  // NOTE:  This is the number of words the stack will hold, not the number of</div><div id="422" class="line none">  422  *  // bytes.  For example, if each stack item is 32-bits, and this is set to 100,</div><div id="423" class="line none">  423  *  // then 400 bytes (100 * 32-bits) will be allocated.</div><div id="424" class="line none">  424  #define STACK_SIZE 200</div><div id="425" class="line none">  425  *</div><div id="426" class="line none">  426  *  // Structure that will hold the TCB of the task being created.</div><div id="427" class="line none">  427  *  StaticTask_t xTaskBuffer;</div><div id="428" class="line none">  428  *</div><div id="429" class="line none">  429  *  // Buffer that the task being created will use as its stack.  Note this is</div><div id="430" class="line none">  430  *  // an array of StackType_t variables.  The size of StackType_t is dependent on</div><div id="431" class="line none">  431  *  // the RTOS port.</div><div id="432" class="line none">  432  *  StackType_t xStack[ STACK_SIZE ];</div><div id="433" class="line none">  433  *</div><div id="434" class="line none">  434  *  // Function that implements the task being created.</div><div id="435" class="line none">  435  *  void vTaskCode( void * pvParameters )</div><div id="436" class="line none">  436  *  {</div><div id="437" class="line none">  437  *      // The parameter value is expected to be 1 as 1 is passed in the</div><div id="438" class="line none">  438  *      // pvParameters value in the call to xTaskCreateStatic().</div><div id="439" class="line none">  439  *      configASSERT( ( uint32_t ) pvParameters == 1UL );</div><div id="440" class="line none">  440  *</div><div id="441" class="line none">  441  *      for( ;; )</div><div id="442" class="line none">  442  *      {</div><div id="443" class="line none">  443  *          // Task code goes here.</div><div id="444" class="line none">  444  *      }</div><div id="445" class="line none">  445  *  }</div><div id="446" class="line none">  446  *</div><div id="447" class="line none">  447  *  // Function that creates a task.</div><div id="448" class="line none">  448  *  void vOtherFunction( void )</div><div id="449" class="line none">  449  *  {</div><div id="450" class="line none">  450  *      TaskHandle_t xHandle = NULL;</div><div id="451" class="line none">  451  *</div><div id="452" class="line none">  452  *      // Create the task without using any dynamic memory allocation.</div><div id="453" class="line none">  453  *      xHandle = xTaskCreateStatic(</div><div id="454" class="line none">  454  *                    vTaskCode,       // Function that implements the task.</div><div id="455" class="line none">  455  *                    "NAME",          // Text name for the task.</div><div id="456" class="line none">  456  *                    STACK_SIZE,      // Stack size in words, not bytes.</div><div id="457" class="line none">  457  *                    ( void * ) 1,    // Parameter passed into the task.</div><div id="458" class="line none">  458  *                    tskIDLE_PRIORITY,// Priority at which the task is created.</div><div id="459" class="line none">  459  *                    xStack,          // Array to use as the task's stack.</div><div id="460" class="line none">  460  *                    &amp;xTaskBuffer );  // Variable to hold the task's data structure.</div><div id="461" class="line none">  461  *</div><div id="462" class="line none">  462  *      // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have</div><div id="463" class="line none">  463  *      // been created, and xHandle will be the task's handle.  Use the handle</div><div id="464" class="line none">  464  *      // to suspend the task.</div><div id="465" class="line none">  465  *      vTaskSuspend( xHandle );</div><div id="466" class="line none">  466  *  }</div><div id="467" class="line none">  467  * @endcode</div><div id="468" class="line none">  468  * \defgroup xTaskCreateStatic xTaskCreateStatic</div><div id="469" class="line none">  469  * \ingroup Tasks</div><div id="470" class="line none">  470  */</div><div id="471" class="line none">  471 #if ( configSUPPORT_STATIC_ALLOCATION == 1 )</div><div id="472" class="line none">  472     <a href="task.h.html#87">TaskHandle_t</a> xTaskCreateStatic( TaskFunction_t pxTaskCode,</div><div id="473" class="line none">  473                                     const char * const <a href="task.h.html#141">pcName</a>, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */</div><div id="474" class="line none">  474                                     const uint32_t ulStackDepth,</div><div id="475" class="line none">  475                                     void * const <a href="task.h.html#143">pvParameters</a>,</div><div id="476" class="line none">  476                                     <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> <a href="task.h.html#144">uxPriority</a>,</div><div id="477" class="line none">  477                                     <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#59">StackType_t</a> * const <a href="task.h.html#145">puxStackBuffer</a>,</div><div id="478" class="line none">  478                                     StaticTask_t * const <a href="task.h.html#148">pxTaskBuffer</a> ) PRIVILEGED_FUNCTION;</div><div id="479" class="line none">  479 #endif /* configSUPPORT_STATIC_ALLOCATION */</div><div id="480" class="line none">  480 </div><div id="481" class="line none">  481 /**</div><div id="482" class="line none">  482  * task. h</div><div id="483" class="line none">  483  * @code{c}</div><div id="484" class="line none">  484  * BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</div><div id="485" class="line none">  485  * @endcode</div><div id="486" class="line none">  486  *</div><div id="487" class="line none">  487  * Only available when configSUPPORT_DYNAMIC_ALLOCATION is set to 1.</div><div id="488" class="line none">  488  *</div><div id="489" class="line none">  489  * xTaskCreateRestricted() should only be used in systems that include an MPU</div><div id="490" class="line none">  490  * implementation.</div><div id="491" class="line none">  491  *</div><div id="492" class="line none">  492  * Create a new task and add it to the list of tasks that are ready to run.</div><div id="493" class="line none">  493  * The function parameters define the memory regions and associated access</div><div id="494" class="line none">  494  * permissions allocated to the task.</div><div id="495" class="line none">  495  *</div><div id="496" class="line none">  496  * See xTaskCreateRestrictedStatic() for a version that does not use any</div><div id="497" class="line none">  497  * dynamic memory allocation.</div><div id="498" class="line none">  498  *</div><div id="499" class="line none">  499  * @param pxTaskDefinition Pointer to a structure that contains a member</div><div id="500" class="line none">  500  * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API</div><div id="501" class="line none">  501  * documentation) plus an optional stack buffer and the memory region</div><div id="502" class="line none">  502  * definitions.</div><div id="503" class="line none">  503  *</div><div id="504" class="line none">  504  * @param pxCreatedTask Used to pass back a handle by which the created task</div><div id="505" class="line none">  505  * can be referenced.</div><div id="506" class="line none">  506  *</div><div id="507" class="line none">  507  * @return pdPASS if the task was successfully created and added to a ready</div><div id="508" class="line none">  508  * list, otherwise an error code defined in the file projdefs.h</div><div id="509" class="line none">  509  *</div><div id="510" class="line none">  510  * Example usage:</div><div id="511" class="line none">  511  * @code{c}</div><div id="512" class="line none">  512  * // Create an TaskParameters_t structure that defines the task to be created.</div><div id="513" class="line none">  513  * static const TaskParameters_t xCheckTaskParameters =</div><div id="514" class="line none">  514  * {</div><div id="515" class="line none">  515  *  vATask,     // pvTaskCode - the function that implements the task.</div><div id="516" class="line none">  516  *  "ATask",    // pcName - just a text name for the task to assist debugging.</div><div id="517" class="line none">  517  *  100,        // usStackDepth - the stack size DEFINED IN WORDS.</div><div id="518" class="line none">  518  *  NULL,       // pvParameters - passed into the task function as the function parameters.</div><div id="519" class="line none">  519  *  ( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.</div><div id="520" class="line none">  520  *  cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.</div><div id="521" class="line none">  521  *</div><div id="522" class="line none">  522  *  // xRegions - Allocate up to three separate memory regions for access by</div><div id="523" class="line none">  523  *  // the task, with appropriate access permissions.  Different processors have</div><div id="524" class="line none">  524  *  // different memory alignment requirements - refer to the FreeRTOS documentation</div><div id="525" class="line none">  525  *  // for full information.</div><div id="526" class="line none">  526  *  {</div><div id="527" class="line none">  527  *      // Base address                 Length  Parameters</div><div id="528" class="line none">  528  *      { cReadWriteArray,              32,     portMPU_REGION_READ_WRITE },</div><div id="529" class="line none">  529  *      { cReadOnlyArray,               32,     portMPU_REGION_READ_ONLY },</div><div id="530" class="line none">  530  *      { cPrivilegedOnlyAccessArray,   128,    portMPU_REGION_PRIVILEGED_READ_WRITE }</div><div id="531" class="line none">  531  *  }</div><div id="532" class="line none">  532  * };</div><div id="533" class="line none">  533  *</div><div id="534" class="line none">  534  * int main( void )</div><div id="535" class="line none">  535  * {</div><div id="536" class="line none">  536  * TaskHandle_t xHandle;</div><div id="537" class="line none">  537  *</div><div id="538" class="line none">  538  *  // Create a task from the const structure defined above.  The task handle</div><div id="539" class="line none">  539  *  // is requested (the second parameter is not NULL) but in this case just for</div><div id="540" class="line none">  540  *  // demonstration purposes as its not actually used.</div><div id="541" class="line none">  541  *  xTaskCreateRestricted( &amp;xRegTest1Parameters, &amp;xHandle );</div><div id="542" class="line none">  542  *</div><div id="543" class="line none">  543  *  // Start the scheduler.</div><div id="544" class="line none">  544  *  vTaskStartScheduler();</div><div id="545" class="line none">  545  *</div><div id="546" class="line none">  546  *  // Will only get here if there was insufficient memory to create the idle</div><div id="547" class="line none">  547  *  // and/or timer task.</div><div id="548" class="line none">  548  *  for( ;; );</div><div id="549" class="line none">  549  * }</div><div id="550" class="line none">  550  * @endcode</div><div id="551" class="line none">  551  * \defgroup xTaskCreateRestricted xTaskCreateRestricted</div><div id="552" class="line none">  552  * \ingroup Tasks</div><div id="553" class="line none">  553  */</div><div id="554" class="line none">  554 #if ( <a href="portable.h.html#73">portUSING_MPU_WRAPPERS</a> == 1 )</div><div id="555" class="line none">  555     <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskCreateRestricted( const <a href="task.h.html#150">TaskParameters_t</a> * const pxTaskDefinition,</div><div id="556" class="line none">  556                                       <a href="task.h.html#87">TaskHandle_t</a> * pxCreatedTask ) PRIVILEGED_FUNCTION;</div><div id="557" class="line none">  557 #endif</div><div id="558" class="line none">  558 </div><div id="559" class="line none">  559 /**</div><div id="560" class="line none">  560  * task. h</div><div id="561" class="line none">  561  * @code{c}</div><div id="562" class="line none">  562  * BaseType_t xTaskCreateRestrictedStatic( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</div><div id="563" class="line none">  563  * @endcode</div><div id="564" class="line none">  564  *</div><div id="565" class="line none">  565  * Only available when configSUPPORT_STATIC_ALLOCATION is set to 1.</div><div id="566" class="line none">  566  *</div><div id="567" class="line none">  567  * xTaskCreateRestrictedStatic() should only be used in systems that include an</div><div id="568" class="line none">  568  * MPU implementation.</div><div id="569" class="line none">  569  *</div><div id="570" class="line none">  570  * Internally, within the FreeRTOS implementation, tasks use two blocks of</div><div id="571" class="line none">  571  * memory.  The first block is used to hold the task's data structures.  The</div><div id="572" class="line none">  572  * second block is used by the task as its stack.  If a task is created using</div><div id="573" class="line none">  573  * xTaskCreateRestricted() then the stack is provided by the application writer,</div><div id="574" class="line none">  574  * and the memory used to hold the task's data structure is automatically</div><div id="575" class="line none">  575  * dynamically allocated inside the xTaskCreateRestricted() function.  If a task</div><div id="576" class="line none">  576  * is created using xTaskCreateRestrictedStatic() then the application writer</div><div id="577" class="line none">  577  * must provide the memory used to hold the task's data structures too.</div><div id="578" class="line none">  578  * xTaskCreateRestrictedStatic() therefore allows a memory protected task to be</div><div id="579" class="line none">  579  * created without using any dynamic memory allocation.</div><div id="580" class="line none">  580  *</div><div id="581" class="line none">  581  * @param pxTaskDefinition Pointer to a structure that contains a member</div><div id="582" class="line none">  582  * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API</div><div id="583" class="line none">  583  * documentation) plus an optional stack buffer and the memory region</div><div id="584" class="line none">  584  * definitions.  If configSUPPORT_STATIC_ALLOCATION is set to 1 the structure</div><div id="585" class="line none">  585  * contains an additional member, which is used to point to a variable of type</div><div id="586" class="line none">  586  * StaticTask_t - which is then used to hold the task's data structure.</div><div id="587" class="line none">  587  *</div><div id="588" class="line none">  588  * @param pxCreatedTask Used to pass back a handle by which the created task</div><div id="589" class="line none">  589  * can be referenced.</div><div id="590" class="line none">  590  *</div><div id="591" class="line none">  591  * @return pdPASS if the task was successfully created and added to a ready</div><div id="592" class="line none">  592  * list, otherwise an error code defined in the file projdefs.h</div><div id="593" class="line none">  593  *</div><div id="594" class="line none">  594  * Example usage:</div><div id="595" class="line none">  595  * @code{c}</div><div id="596" class="line none">  596  * // Create an TaskParameters_t structure that defines the task to be created.</div><div id="597" class="line none">  597  * // The StaticTask_t variable is only included in the structure when</div><div id="598" class="line none">  598  * // configSUPPORT_STATIC_ALLOCATION is set to 1.  The PRIVILEGED_DATA macro can</div><div id="599" class="line none">  599  * // be used to force the variable into the RTOS kernel's privileged data area.</div><div id="600" class="line none">  600  * static PRIVILEGED_DATA StaticTask_t xTaskBuffer;</div><div id="601" class="line none">  601  * static const TaskParameters_t xCheckTaskParameters =</div><div id="602" class="line none">  602  * {</div><div id="603" class="line none">  603  *  vATask,     // pvTaskCode - the function that implements the task.</div><div id="604" class="line none">  604  *  "ATask",    // pcName - just a text name for the task to assist debugging.</div><div id="605" class="line none">  605  *  100,        // usStackDepth - the stack size DEFINED IN WORDS.</div><div id="606" class="line none">  606  *  NULL,       // pvParameters - passed into the task function as the function parameters.</div><div id="607" class="line none">  607  *  ( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.</div><div id="608" class="line none">  608  *  cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.</div><div id="609" class="line none">  609  *</div><div id="610" class="line none">  610  *  // xRegions - Allocate up to three separate memory regions for access by</div><div id="611" class="line none">  611  *  // the task, with appropriate access permissions.  Different processors have</div><div id="612" class="line none">  612  *  // different memory alignment requirements - refer to the FreeRTOS documentation</div><div id="613" class="line none">  613  *  // for full information.</div><div id="614" class="line none">  614  *  {</div><div id="615" class="line none">  615  *      // Base address                 Length  Parameters</div><div id="616" class="line none">  616  *      { cReadWriteArray,              32,     portMPU_REGION_READ_WRITE },</div><div id="617" class="line none">  617  *      { cReadOnlyArray,               32,     portMPU_REGION_READ_ONLY },</div><div id="618" class="line none">  618  *      { cPrivilegedOnlyAccessArray,   128,    portMPU_REGION_PRIVILEGED_READ_WRITE }</div><div id="619" class="line none">  619  *  }</div><div id="620" class="line none">  620  *</div><div id="621" class="line none">  621  *  &amp;xTaskBuffer; // Holds the task's data structure.</div><div id="622" class="line none">  622  * };</div><div id="623" class="line none">  623  *</div><div id="624" class="line none">  624  * int main( void )</div><div id="625" class="line none">  625  * {</div><div id="626" class="line none">  626  * TaskHandle_t xHandle;</div><div id="627" class="line none">  627  *</div><div id="628" class="line none">  628  *  // Create a task from the const structure defined above.  The task handle</div><div id="629" class="line none">  629  *  // is requested (the second parameter is not NULL) but in this case just for</div><div id="630" class="line none">  630  *  // demonstration purposes as its not actually used.</div><div id="631" class="line none">  631  *  xTaskCreateRestricted( &amp;xRegTest1Parameters, &amp;xHandle );</div><div id="632" class="line none">  632  *</div><div id="633" class="line none">  633  *  // Start the scheduler.</div><div id="634" class="line none">  634  *  vTaskStartScheduler();</div><div id="635" class="line none">  635  *</div><div id="636" class="line none">  636  *  // Will only get here if there was insufficient memory to create the idle</div><div id="637" class="line none">  637  *  // and/or timer task.</div><div id="638" class="line none">  638  *  for( ;; );</div><div id="639" class="line none">  639  * }</div><div id="640" class="line none">  640  * @endcode</div><div id="641" class="line none">  641  * \defgroup xTaskCreateRestrictedStatic xTaskCreateRestrictedStatic</div><div id="642" class="line none">  642  * \ingroup Tasks</div><div id="643" class="line none">  643  */</div><div id="644" class="line none">  644 #if ( ( <a href="portable.h.html#73">portUSING_MPU_WRAPPERS</a> == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 1 ) )</div><div id="645" class="line none">  645     <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskCreateRestrictedStatic( const <a href="task.h.html#150">TaskParameters_t</a> * const pxTaskDefinition,</div><div id="646" class="line none">  646                                             <a href="task.h.html#87">TaskHandle_t</a> * pxCreatedTask ) PRIVILEGED_FUNCTION;</div><div id="647" class="line none">  647 #endif</div><div id="648" class="line none">  648 </div><div id="649" class="line none">  649 /**</div><div id="650" class="line none">  650  * task. h</div><div id="651" class="line none">  651  * @code{c}</div><div id="652" class="line none">  652  * void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</div><div id="653" class="line none">  653  * @endcode</div><div id="654" class="line none">  654  *</div><div id="655" class="line none">  655  * Memory regions are assigned to a restricted task when the task is created by</div><div id="656" class="line none">  656  * a call to xTaskCreateRestricted().  These regions can be redefined using</div><div id="657" class="line none">  657  * vTaskAllocateMPURegions().</div><div id="658" class="line none">  658  *</div><div id="659" class="line none">  659  * @param xTask The handle of the task being updated.</div><div id="660" class="line none">  660  *</div><div id="661" class="line none">  661  * @param xRegions A pointer to a MemoryRegion_t structure that contains the</div><div id="662" class="line none">  662  * new memory region definitions.</div><div id="663" class="line none">  663  *</div><div id="664" class="line none">  664  * Example usage:</div><div id="665" class="line none">  665  * @code{c}</div><div id="666" class="line none">  666  * // Define an array of MemoryRegion_t structures that configures an MPU region</div><div id="667" class="line none">  667  * // allowing read/write access for 1024 bytes starting at the beginning of the</div><div id="668" class="line none">  668  * // ucOneKByte array.  The other two of the maximum 3 definable regions are</div><div id="669" class="line none">  669  * // unused so set to zero.</div><div id="670" class="line none">  670  * static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =</div><div id="671" class="line none">  671  * {</div><div id="672" class="line none">  672  *  // Base address     Length      Parameters</div><div id="673" class="line none">  673  *  { ucOneKByte,       1024,       portMPU_REGION_READ_WRITE },</div><div id="674" class="line none">  674  *  { 0,                0,          0 },</div><div id="675" class="line none">  675  *  { 0,                0,          0 }</div><div id="676" class="line none">  676  * };</div><div id="677" class="line none">  677  *</div><div id="678" class="line none">  678  * void vATask( void *pvParameters )</div><div id="679" class="line none">  679  * {</div><div id="680" class="line none">  680  *  // This task was created such that it has access to certain regions of</div><div id="681" class="line none">  681  *  // memory as defined by the MPU configuration.  At some point it is</div><div id="682" class="line none">  682  *  // desired that these MPU regions are replaced with that defined in the</div><div id="683" class="line none">  683  *  // xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()</div><div id="684" class="line none">  684  *  // for this purpose.  NULL is used as the task handle to indicate that this</div><div id="685" class="line none">  685  *  // function should modify the MPU regions of the calling task.</div><div id="686" class="line none">  686  *  vTaskAllocateMPURegions( NULL, xAltRegions );</div><div id="687" class="line none">  687  *</div><div id="688" class="line none">  688  *  // Now the task can continue its function, but from this point on can only</div><div id="689" class="line none">  689  *  // access its stack and the ucOneKByte array (unless any other statically</div><div id="690" class="line none">  690  *  // defined or shared regions have been declared elsewhere).</div><div id="691" class="line none">  691  * }</div><div id="692" class="line none">  692  * @endcode</div><div id="693" class="line none">  693  * \defgroup xTaskCreateRestricted xTaskCreateRestricted</div><div id="694" class="line none">  694  * \ingroup Tasks</div><div id="695" class="line none">  695  */</div><div id="696" class="line none">  696 void vTaskAllocateMPURegions( <a href="task.h.html#87">TaskHandle_t</a> xTask,</div><div id="697" class="line none">  697                               const <a href="task.h.html#133">MemoryRegion_t</a> * const pxRegions ) PRIVILEGED_FUNCTION;</div><div id="698" class="line none">  698 </div><div id="699" class="line none">  699 /**</div><div id="700" class="line none">  700  * task. h</div><div id="701" class="line none">  701  * @code{c}</div><div id="702" class="line none">  702  * void vTaskDelete( TaskHandle_t xTaskToDelete );</div><div id="703" class="line none">  703  * @endcode</div><div id="704" class="line none">  704  *</div><div id="705" class="line none">  705  * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.</div><div id="706" class="line none">  706  * See the configuration section for more information.</div><div id="707" class="line none">  707  *</div><div id="708" class="line none">  708  * Remove a task from the RTOS real time kernel's management.  The task being</div><div id="709" class="line none">  709  * deleted will be removed from all ready, blocked, suspended and event lists.</div><div id="710" class="line none">  710  *</div><div id="711" class="line none">  711  * NOTE:  The idle task is responsible for freeing the kernel allocated</div><div id="712" class="line none">  712  * memory from tasks that have been deleted.  It is therefore important that</div><div id="713" class="line none">  713  * the idle task is not starved of microcontroller processing time if your</div><div id="714" class="line none">  714  * application makes any calls to vTaskDelete ().  Memory allocated by the</div><div id="715" class="line none">  715  * task code is not automatically freed, and should be freed before the task</div><div id="716" class="line none">  716  * is deleted.</div><div id="717" class="line none">  717  *</div><div id="718" class="line none">  718  * See the demo application file death.c for sample code that utilises</div><div id="719" class="line none">  719  * vTaskDelete ().</div><div id="720" class="line none">  720  *</div><div id="721" class="line none">  721  * @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will</div><div id="722" class="line none">  722  * cause the calling task to be deleted.</div><div id="723" class="line none">  723  *</div><div id="724" class="line none">  724  * Example usage:</div><div id="725" class="line none">  725  * @code{c}</div><div id="726" class="line none">  726  * void vOtherFunction( void )</div><div id="727" class="line none">  727  * {</div><div id="728" class="line none">  728  * TaskHandle_t xHandle;</div><div id="729" class="line none">  729  *</div><div id="730" class="line none">  730  *   // Create the task, storing the handle.</div><div id="731" class="line none">  731  *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &amp;xHandle );</div><div id="732" class="line none">  732  *</div><div id="733" class="line none">  733  *   // Use the handle to delete the task.</div><div id="734" class="line none">  734  *   vTaskDelete( xHandle );</div><div id="735" class="line none">  735  * }</div><div id="736" class="line none">  736  * @endcode</div><div id="737" class="line none">  737  * \defgroup vTaskDelete vTaskDelete</div><div id="738" class="line none">  738  * \ingroup Tasks</div><div id="739" class="line none">  739  */</div><div id="740" class="line none">  740 void vTaskDelete( <a href="task.h.html#87">TaskHandle_t</a> xTaskToDelete ) PRIVILEGED_FUNCTION;</div><div id="741" class="line none">  741 </div><div id="742" class="line none">  742 /*-----------------------------------------------------------</div><div id="743" class="line none">  743 * TASK CONTROL API</div><div id="744" class="line none">  744 *----------------------------------------------------------*/</div><div id="745" class="line none">  745 </div><div id="746" class="line none">  746 /**</div><div id="747" class="line none">  747  * task. h</div><div id="748" class="line none">  748  * @code{c}</div><div id="749" class="line none">  749  * void vTaskDelay( const TickType_t xTicksToDelay );</div><div id="750" class="line none">  750  * @endcode</div><div id="751" class="line none">  751  *</div><div id="752" class="line none">  752  * Delay a task for a given number of ticks.  The actual time that the</div><div id="753" class="line none">  753  * task remains blocked depends on the tick rate.  The constant</div><div id="754" class="line none">  754  * portTICK_PERIOD_MS can be used to calculate real time from the tick</div><div id="755" class="line none">  755  * rate - with the resolution of one tick period.</div><div id="756" class="line none">  756  *</div><div id="757" class="line none">  757  * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.</div><div id="758" class="line none">  758  * See the configuration section for more information.</div><div id="759" class="line none">  759  *</div><div id="760" class="line none">  760  *</div><div id="761" class="line none">  761  * vTaskDelay() specifies a time at which the task wishes to unblock relative to</div><div id="762" class="line none">  762  * the time at which vTaskDelay() is called.  For example, specifying a block</div><div id="763" class="line none">  763  * period of 100 ticks will cause the task to unblock 100 ticks after</div><div id="764" class="line none">  764  * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method</div><div id="765" class="line none">  765  * of controlling the frequency of a periodic task as the path taken through the</div><div id="766" class="line none">  766  * code, as well as other task and interrupt activity, will affect the frequency</div><div id="767" class="line none">  767  * at which vTaskDelay() gets called and therefore the time at which the task</div><div id="768" class="line none">  768  * next executes.  See xTaskDelayUntil() for an alternative API function designed</div><div id="769" class="line none">  769  * to facilitate fixed frequency execution.  It does this by specifying an</div><div id="770" class="line none">  770  * absolute time (rather than a relative time) at which the calling task should</div><div id="771" class="line none">  771  * unblock.</div><div id="772" class="line none">  772  *</div><div id="773" class="line none">  773  * @param xTicksToDelay The amount of time, in tick periods, that</div><div id="774" class="line none">  774  * the calling task should block.</div><div id="775" class="line none">  775  *</div><div id="776" class="line none">  776  * Example usage:</div><div id="777" class="line none">  777  *</div><div id="778" class="line none">  778  * void vTaskFunction( void * pvParameters )</div><div id="779" class="line none">  779  * {</div><div id="780" class="line none">  780  * // Block for 500ms.</div><div id="781" class="line none">  781  * const TickType_t xDelay = 500 / portTICK_PERIOD_MS;</div><div id="782" class="line none">  782  *</div><div id="783" class="line none">  783  *   for( ;; )</div><div id="784" class="line none">  784  *   {</div><div id="785" class="line none">  785  *       // Simply toggle the LED every 500ms, blocking between each toggle.</div><div id="786" class="line none">  786  *       vToggleLED();</div><div id="787" class="line none">  787  *       vTaskDelay( xDelay );</div><div id="788" class="line none">  788  *   }</div><div id="789" class="line none">  789  * }</div><div id="790" class="line none">  790  *</div><div id="791" class="line none">  791  * \defgroup vTaskDelay vTaskDelay</div><div id="792" class="line none">  792  * \ingroup TaskCtrl</div><div id="793" class="line none">  793  */</div><div id="794" class="line none">  794 void vTaskDelay( const <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> xTicksToDelay ) PRIVILEGED_FUNCTION;</div><div id="795" class="line none">  795 </div><div id="796" class="line none">  796 /**</div><div id="797" class="line none">  797  * task. h</div><div id="798" class="line none">  798  * @code{c}</div><div id="799" class="line none">  799  * BaseType_t xTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</div><div id="800" class="line none">  800  * @endcode</div><div id="801" class="line none">  801  *</div><div id="802" class="line none">  802  * INCLUDE_xTaskDelayUntil must be defined as 1 for this function to be available.</div><div id="803" class="line none">  803  * See the configuration section for more information.</div><div id="804" class="line none">  804  *</div><div id="805" class="line none">  805  * Delay a task until a specified time.  This function can be used by periodic</div><div id="806" class="line none">  806  * tasks to ensure a constant execution frequency.</div><div id="807" class="line none">  807  *</div><div id="808" class="line none">  808  * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will</div><div id="809" class="line none">  809  * cause a task to block for the specified number of ticks from the time vTaskDelay () is</div><div id="810" class="line none">  810  * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed</div><div id="811" class="line none">  811  * execution frequency as the time between a task starting to execute and that task</div><div id="812" class="line none">  812  * calling vTaskDelay () may not be fixed [the task may take a different path though the</div><div id="813" class="line none">  813  * code between calls, or may get interrupted or preempted a different number of times</div><div id="814" class="line none">  814  * each time it executes].</div><div id="815" class="line none">  815  *</div><div id="816" class="line none">  816  * Whereas vTaskDelay () specifies a wake time relative to the time at which the function</div><div id="817" class="line none">  817  * is called, xTaskDelayUntil () specifies the absolute (exact) time at which it wishes to</div><div id="818" class="line none">  818  * unblock.</div><div id="819" class="line none">  819  *</div><div id="820" class="line none">  820  * The macro pdMS_TO_TICKS() can be used to calculate the number of ticks from a</div><div id="821" class="line none">  821  * time specified in milliseconds with a resolution of one tick period.</div><div id="822" class="line none">  822  *</div><div id="823" class="line none">  823  * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the</div><div id="824" class="line none">  824  * task was last unblocked.  The variable must be initialised with the current time</div><div id="825" class="line none">  825  * prior to its first use (see the example below).  Following this the variable is</div><div id="826" class="line none">  826  * automatically updated within xTaskDelayUntil ().</div><div id="827" class="line none">  827  *</div><div id="828" class="line none">  828  * @param xTimeIncrement The cycle time period.  The task will be unblocked at</div><div id="829" class="line none">  829  * time *pxPreviousWakeTime + xTimeIncrement.  Calling xTaskDelayUntil with the</div><div id="830" class="line none">  830  * same xTimeIncrement parameter value will cause the task to execute with</div><div id="831" class="line none">  831  * a fixed interface period.</div><div id="832" class="line none">  832  *</div><div id="833" class="line none">  833  * @return Value which can be used to check whether the task was actually delayed.</div><div id="834" class="line none">  834  * Will be pdTRUE if the task way delayed and pdFALSE otherwise.  A task will not</div><div id="835" class="line none">  835  * be delayed if the next expected wake time is in the past.</div><div id="836" class="line none">  836  *</div><div id="837" class="line none">  837  * Example usage:</div><div id="838" class="line none">  838  * @code{c}</div><div id="839" class="line none">  839  * // Perform an action every 10 ticks.</div><div id="840" class="line none">  840  * void vTaskFunction( void * pvParameters )</div><div id="841" class="line none">  841  * {</div><div id="842" class="line none">  842  * TickType_t xLastWakeTime;</div><div id="843" class="line none">  843  * const TickType_t xFrequency = 10;</div><div id="844" class="line none">  844  * BaseType_t xWasDelayed;</div><div id="845" class="line none">  845  *</div><div id="846" class="line none">  846  *     // Initialise the xLastWakeTime variable with the current time.</div><div id="847" class="line none">  847  *     xLastWakeTime = xTaskGetTickCount ();</div><div id="848" class="line none">  848  *     for( ;; )</div><div id="849" class="line none">  849  *     {</div><div id="850" class="line none">  850  *         // Wait for the next cycle.</div><div id="851" class="line none">  851  *         xWasDelayed = xTaskDelayUntil( &amp;xLastWakeTime, xFrequency );</div><div id="852" class="line none">  852  *</div><div id="853" class="line none">  853  *         // Perform action here. xWasDelayed value can be used to determine</div><div id="854" class="line none">  854  *         // whether a deadline was missed if the code here took too long.</div><div id="855" class="line none">  855  *     }</div><div id="856" class="line none">  856  * }</div><div id="857" class="line none">  857  * @endcode</div><div id="858" class="line none">  858  * \defgroup xTaskDelayUntil xTaskDelayUntil</div><div id="859" class="line none">  859  * \ingroup TaskCtrl</div><div id="860" class="line none">  860  */</div><div id="861" class="line none">  861 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskDelayUntil( <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> * const pxPreviousWakeTime,</div><div id="862" class="line none">  862                             const <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> xTimeIncrement ) PRIVILEGED_FUNCTION;</div><div id="863" class="line none">  863 </div><div id="864" class="line none">  864 /*</div><div id="865" class="line none">  865  * vTaskDelayUntil() is the older version of xTaskDelayUntil() and does not</div><div id="866" class="line none">  866  * return a value.</div><div id="867" class="line none">  867  */</div><div id="868" class="line none">  868 #define <a href="task.h.html#868">vTaskDelayUntil</a>( pxPreviousWakeTime, xTimeIncrement )           \</div><div id="869" class="line none">  869     {                                                                   \</div><div id="870" class="line none">  870         ( void ) xTaskDelayUntil( pxPreviousWakeTime, xTimeIncrement ); \</div><div id="871" class="line none">  871     }</div><div id="872" class="line none">  872 </div><div id="873" class="line none">  873 </div><div id="874" class="line none">  874 /**</div><div id="875" class="line none">  875  * task. h</div><div id="876" class="line none">  876  * @code{c}</div><div id="877" class="line none">  877  * BaseType_t xTaskAbortDelay( TaskHandle_t xTask );</div><div id="878" class="line none">  878  * @endcode</div><div id="879" class="line none">  879  *</div><div id="880" class="line none">  880  * INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this</div><div id="881" class="line none">  881  * function to be available.</div><div id="882" class="line none">  882  *</div><div id="883" class="line none">  883  * A task will enter the Blocked state when it is waiting for an event.  The</div><div id="884" class="line none">  884  * event it is waiting for can be a temporal event (waiting for a time), such</div><div id="885" class="line none">  885  * as when vTaskDelay() is called, or an event on an object, such as when</div><div id="886" class="line none">  886  * xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task</div><div id="887" class="line none">  887  * that is in the Blocked state is used in a call to xTaskAbortDelay() then the</div><div id="888" class="line none">  888  * task will leave the Blocked state, and return from whichever function call</div><div id="889" class="line none">  889  * placed the task into the Blocked state.</div><div id="890" class="line none">  890  *</div><div id="891" class="line none">  891  * There is no 'FromISR' version of this function as an interrupt would need to</div><div id="892" class="line none">  892  * know which object a task was blocked on in order to know which actions to</div><div id="893" class="line none">  893  * take.  For example, if the task was blocked on a queue the interrupt handler</div><div id="894" class="line none">  894  * would then need to know if the queue was locked.</div><div id="895" class="line none">  895  *</div><div id="896" class="line none">  896  * @param xTask The handle of the task to remove from the Blocked state.</div><div id="897" class="line none">  897  *</div><div id="898" class="line none">  898  * @return If the task referenced by xTask was not in the Blocked state then</div><div id="899" class="line none">  899  * pdFAIL is returned.  Otherwise pdPASS is returned.</div><div id="900" class="line none">  900  *</div><div id="901" class="line none">  901  * \defgroup xTaskAbortDelay xTaskAbortDelay</div><div id="902" class="line none">  902  * \ingroup TaskCtrl</div><div id="903" class="line none">  903  */</div><div id="904" class="line none">  904 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskAbortDelay( <a href="task.h.html#87">TaskHandle_t</a> xTask ) PRIVILEGED_FUNCTION;</div><div id="905" class="line none">  905 </div><div id="906" class="line none">  906 /**</div><div id="907" class="line none">  907  * task. h</div><div id="908" class="line none">  908  * @code{c}</div><div id="909" class="line none">  909  * UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask );</div><div id="910" class="line none">  910  * @endcode</div><div id="911" class="line none">  911  *</div><div id="912" class="line none">  912  * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.</div><div id="913" class="line none">  913  * See the configuration section for more information.</div><div id="914" class="line none">  914  *</div><div id="915" class="line none">  915  * Obtain the priority of any task.</div><div id="916" class="line none">  916  *</div><div id="917" class="line none">  917  * @param xTask Handle of the task to be queried.  Passing a NULL</div><div id="918" class="line none">  918  * handle results in the priority of the calling task being returned.</div><div id="919" class="line none">  919  *</div><div id="920" class="line none">  920  * @return The priority of xTask.</div><div id="921" class="line none">  921  *</div><div id="922" class="line none">  922  * Example usage:</div><div id="923" class="line none">  923  * @code{c}</div><div id="924" class="line none">  924  * void vAFunction( void )</div><div id="925" class="line none">  925  * {</div><div id="926" class="line none">  926  * TaskHandle_t xHandle;</div><div id="927" class="line none">  927  *</div><div id="928" class="line none">  928  *   // Create a task, storing the handle.</div><div id="929" class="line none">  929  *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &amp;xHandle );</div><div id="930" class="line none">  930  *</div><div id="931" class="line none">  931  *   // ...</div><div id="932" class="line none">  932  *</div><div id="933" class="line none">  933  *   // Use the handle to obtain the priority of the created task.</div><div id="934" class="line none">  934  *   // It was created with tskIDLE_PRIORITY, but may have changed</div><div id="935" class="line none">  935  *   // it itself.</div><div id="936" class="line none">  936  *   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )</div><div id="937" class="line none">  937  *   {</div><div id="938" class="line none">  938  *       // The task has changed it's priority.</div><div id="939" class="line none">  939  *   }</div><div id="940" class="line none">  940  *</div><div id="941" class="line none">  941  *   // ...</div><div id="942" class="line none">  942  *</div><div id="943" class="line none">  943  *   // Is our priority higher than the created task?</div><div id="944" class="line none">  944  *   if( uxTaskPriorityGet( xHandle ) &lt; uxTaskPriorityGet( NULL ) )</div><div id="945" class="line none">  945  *   {</div><div id="946" class="line none">  946  *       // Our priority (obtained using NULL handle) is higher.</div><div id="947" class="line none">  947  *   }</div><div id="948" class="line none">  948  * }</div><div id="949" class="line none">  949  * @endcode</div><div id="950" class="line none">  950  * \defgroup uxTaskPriorityGet uxTaskPriorityGet</div><div id="951" class="line none">  951  * \ingroup TaskCtrl</div><div id="952" class="line none">  952  */</div><div id="953" class="line none">  953 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxTaskPriorityGet( const <a href="task.h.html#87">TaskHandle_t</a> xTask ) PRIVILEGED_FUNCTION;</div><div id="954" class="line none">  954 </div><div id="955" class="line none">  955 /**</div><div id="956" class="line none">  956  * task. h</div><div id="957" class="line none">  957  * @code{c}</div><div id="958" class="line none">  958  * UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask );</div><div id="959" class="line none">  959  * @endcode</div><div id="960" class="line none">  960  *</div><div id="961" class="line none">  961  * A version of uxTaskPriorityGet() that can be used from an ISR.</div><div id="962" class="line none">  962  */</div><div id="963" class="line none">  963 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxTaskPriorityGetFromISR( const <a href="task.h.html#87">TaskHandle_t</a> xTask ) PRIVILEGED_FUNCTION;</div><div id="964" class="line none">  964 </div><div id="965" class="line none">  965 /**</div><div id="966" class="line none">  966  * task. h</div><div id="967" class="line none">  967  * @code{c}</div><div id="968" class="line none">  968  * eTaskState eTaskGetState( TaskHandle_t xTask );</div><div id="969" class="line none">  969  * @endcode</div><div id="970" class="line none">  970  *</div><div id="971" class="line none">  971  * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.</div><div id="972" class="line none">  972  * See the configuration section for more information.</div><div id="973" class="line none">  973  *</div><div id="974" class="line none">  974  * Obtain the state of any task.  States are encoded by the eTaskState</div><div id="975" class="line none">  975  * enumerated type.</div><div id="976" class="line none">  976  *</div><div id="977" class="line none">  977  * @param xTask Handle of the task to be queried.</div><div id="978" class="line none">  978  *</div><div id="979" class="line none">  979  * @return The state of xTask at the time the function was called.  Note the</div><div id="980" class="line none">  980  * state of the task might change between the function being called, and the</div><div id="981" class="line none">  981  * functions return value being tested by the calling task.</div><div id="982" class="line none">  982  */</div><div id="983" class="line none">  983 <a href="task.h.html#104">eTaskState</a> eTaskGetState( <a href="task.h.html#87">TaskHandle_t</a> xTask ) PRIVILEGED_FUNCTION;</div><div id="984" class="line none">  984 </div><div id="985" class="line none">  985 /**</div><div id="986" class="line none">  986  * task. h</div><div id="987" class="line none">  987  * @code{c}</div><div id="988" class="line none">  988  * void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );</div><div id="989" class="line none">  989  * @endcode</div><div id="990" class="line none">  990  *</div><div id="991" class="line none">  991  * configUSE_TRACE_FACILITY must be defined as 1 for this function to be</div><div id="992" class="line none">  992  * available.  See the configuration section for more information.</div><div id="993" class="line none">  993  *</div><div id="994" class="line none">  994  * Populates a TaskStatus_t structure with information about a task.</div><div id="995" class="line none">  995  *</div><div id="996" class="line none">  996  * @param xTask Handle of the task being queried.  If xTask is NULL then</div><div id="997" class="line none">  997  * information will be returned about the calling task.</div><div id="998" class="line none">  998  *</div><div id="999" class="line none">  999  * @param pxTaskStatus A pointer to the TaskStatus_t structure that will be</div><div id="1000" class="line none"> 1000  * filled with information about the task referenced by the handle passed using</div><div id="1001" class="line none"> 1001  * the xTask parameter.</div><div id="1002" class="line none"> 1002  *</div><div id="1003" class="line none"> 1003  * @param xGetFreeStackSpace The TaskStatus_t structure contains a member to report</div><div id="1004" class="line none"> 1004  * the stack high water mark of the task being queried.  Calculating the stack</div><div id="1005" class="line none"> 1005  * high water mark takes a relatively long time, and can make the system</div><div id="1006" class="line none"> 1006  * temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to</div><div id="1007" class="line none"> 1007  * allow the high water mark checking to be skipped.  The high watermark value</div><div id="1008" class="line none"> 1008  * will only be written to the TaskStatus_t structure if xGetFreeStackSpace is</div><div id="1009" class="line none"> 1009  * not set to pdFALSE;</div><div id="1010" class="line none"> 1010  *</div><div id="1011" class="line none"> 1011  * @param eState The TaskStatus_t structure contains a member to report the</div><div id="1012" class="line none"> 1012  * state of the task being queried.  Obtaining the task state is not as fast as</div><div id="1013" class="line none"> 1013  * a simple assignment - so the eState parameter is provided to allow the state</div><div id="1014" class="line none"> 1014  * information to be omitted from the TaskStatus_t structure.  To obtain state</div><div id="1015" class="line none"> 1015  * information then set eState to eInvalid - otherwise the value passed in</div><div id="1016" class="line none"> 1016  * eState will be reported as the task state in the TaskStatus_t structure.</div><div id="1017" class="line none"> 1017  *</div><div id="1018" class="line none"> 1018  * Example usage:</div><div id="1019" class="line none"> 1019  * @code{c}</div><div id="1020" class="line none"> 1020  * void vAFunction( void )</div><div id="1021" class="line none"> 1021  * {</div><div id="1022" class="line none"> 1022  * TaskHandle_t xHandle;</div><div id="1023" class="line none"> 1023  * TaskStatus_t xTaskDetails;</div><div id="1024" class="line none"> 1024  *</div><div id="1025" class="line none"> 1025  *  // Obtain the handle of a task from its name.</div><div id="1026" class="line none"> 1026  *  xHandle = xTaskGetHandle( "Task_Name" );</div><div id="1027" class="line none"> 1027  *</div><div id="1028" class="line none"> 1028  *  // Check the handle is not NULL.</div><div id="1029" class="line none"> 1029  *  configASSERT( xHandle );</div><div id="1030" class="line none"> 1030  *</div><div id="1031" class="line none"> 1031  *  // Use the handle to obtain further information about the task.</div><div id="1032" class="line none"> 1032  *  vTaskGetInfo( xHandle,</div><div id="1033" class="line none"> 1033  *                &amp;xTaskDetails,</div><div id="1034" class="line none"> 1034  *                pdTRUE, // Include the high water mark in xTaskDetails.</div><div id="1035" class="line none"> 1035  *                eInvalid ); // Include the task state in xTaskDetails.</div><div id="1036" class="line none"> 1036  * }</div><div id="1037" class="line none"> 1037  * @endcode</div><div id="1038" class="line none"> 1038  * \defgroup vTaskGetInfo vTaskGetInfo</div><div id="1039" class="line none"> 1039  * \ingroup TaskCtrl</div><div id="1040" class="line none"> 1040  */</div><div id="1041" class="line none"> 1041 void vTaskGetInfo( <a href="task.h.html#87">TaskHandle_t</a> xTask,</div><div id="1042" class="line none"> 1042                    <a href="task.h.html#169">TaskStatus_t</a> * pxTaskStatus,</div><div id="1043" class="line none"> 1043                    <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xGetFreeStackSpace,</div><div id="1044" class="line none"> 1044                    <a href="task.h.html#104">eTaskState</a> eState ) PRIVILEGED_FUNCTION;</div><div id="1045" class="line none"> 1045 </div><div id="1046" class="line none"> 1046 /**</div><div id="1047" class="line none"> 1047  * task. h</div><div id="1048" class="line none"> 1048  * @code{c}</div><div id="1049" class="line none"> 1049  * void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</div><div id="1050" class="line none"> 1050  * @endcode</div><div id="1051" class="line none"> 1051  *</div><div id="1052" class="line none"> 1052  * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.</div><div id="1053" class="line none"> 1053  * See the configuration section for more information.</div><div id="1054" class="line none"> 1054  *</div><div id="1055" class="line none"> 1055  * Set the priority of any task.</div><div id="1056" class="line none"> 1056  *</div><div id="1057" class="line none"> 1057  * A context switch will occur before the function returns if the priority</div><div id="1058" class="line none"> 1058  * being set is higher than the currently executing task.</div><div id="1059" class="line none"> 1059  *</div><div id="1060" class="line none"> 1060  * @param xTask Handle to the task for which the priority is being set.</div><div id="1061" class="line none"> 1061  * Passing a NULL handle results in the priority of the calling task being set.</div><div id="1062" class="line none"> 1062  *</div><div id="1063" class="line none"> 1063  * @param uxNewPriority The priority to which the task will be set.</div><div id="1064" class="line none"> 1064  *</div><div id="1065" class="line none"> 1065  * Example usage:</div><div id="1066" class="line none"> 1066  * @code{c}</div><div id="1067" class="line none"> 1067  * void vAFunction( void )</div><div id="1068" class="line none"> 1068  * {</div><div id="1069" class="line none"> 1069  * TaskHandle_t xHandle;</div><div id="1070" class="line none"> 1070  *</div><div id="1071" class="line none"> 1071  *   // Create a task, storing the handle.</div><div id="1072" class="line none"> 1072  *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &amp;xHandle );</div><div id="1073" class="line none"> 1073  *</div><div id="1074" class="line none"> 1074  *   // ...</div><div id="1075" class="line none"> 1075  *</div><div id="1076" class="line none"> 1076  *   // Use the handle to raise the priority of the created task.</div><div id="1077" class="line none"> 1077  *   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );</div><div id="1078" class="line none"> 1078  *</div><div id="1079" class="line none"> 1079  *   // ...</div><div id="1080" class="line none"> 1080  *</div><div id="1081" class="line none"> 1081  *   // Use a NULL handle to raise our priority to the same value.</div><div id="1082" class="line none"> 1082  *   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );</div><div id="1083" class="line none"> 1083  * }</div><div id="1084" class="line none"> 1084  * @endcode</div><div id="1085" class="line none"> 1085  * \defgroup vTaskPrioritySet vTaskPrioritySet</div><div id="1086" class="line none"> 1086  * \ingroup TaskCtrl</div><div id="1087" class="line none"> 1087  */</div><div id="1088" class="line none"> 1088 void vTaskPrioritySet( <a href="task.h.html#87">TaskHandle_t</a> xTask,</div><div id="1089" class="line none"> 1089                        <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxNewPriority ) PRIVILEGED_FUNCTION;</div><div id="1090" class="line none"> 1090 </div><div id="1091" class="line none"> 1091 /**</div><div id="1092" class="line none"> 1092  * task. h</div><div id="1093" class="line none"> 1093  * @code{c}</div><div id="1094" class="line none"> 1094  * void vTaskSuspend( TaskHandle_t xTaskToSuspend );</div><div id="1095" class="line none"> 1095  * @endcode</div><div id="1096" class="line none"> 1096  *</div><div id="1097" class="line none"> 1097  * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.</div><div id="1098" class="line none"> 1098  * See the configuration section for more information.</div><div id="1099" class="line none"> 1099  *</div><div id="1100" class="line none"> 1100  * Suspend any task.  When suspended a task will never get any microcontroller</div><div id="1101" class="line none"> 1101  * processing time, no matter what its priority.</div><div id="1102" class="line none"> 1102  *</div><div id="1103" class="line none"> 1103  * Calls to vTaskSuspend are not accumulative -</div><div id="1104" class="line none"> 1104  * i.e. calling vTaskSuspend () twice on the same task still only requires one</div><div id="1105" class="line none"> 1105  * call to vTaskResume () to ready the suspended task.</div><div id="1106" class="line none"> 1106  *</div><div id="1107" class="line none"> 1107  * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL</div><div id="1108" class="line none"> 1108  * handle will cause the calling task to be suspended.</div><div id="1109" class="line none"> 1109  *</div><div id="1110" class="line none"> 1110  * Example usage:</div><div id="1111" class="line none"> 1111  * @code{c}</div><div id="1112" class="line none"> 1112  * void vAFunction( void )</div><div id="1113" class="line none"> 1113  * {</div><div id="1114" class="line none"> 1114  * TaskHandle_t xHandle;</div><div id="1115" class="line none"> 1115  *</div><div id="1116" class="line none"> 1116  *   // Create a task, storing the handle.</div><div id="1117" class="line none"> 1117  *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &amp;xHandle );</div><div id="1118" class="line none"> 1118  *</div><div id="1119" class="line none"> 1119  *   // ...</div><div id="1120" class="line none"> 1120  *</div><div id="1121" class="line none"> 1121  *   // Use the handle to suspend the created task.</div><div id="1122" class="line none"> 1122  *   vTaskSuspend( xHandle );</div><div id="1123" class="line none"> 1123  *</div><div id="1124" class="line none"> 1124  *   // ...</div><div id="1125" class="line none"> 1125  *</div><div id="1126" class="line none"> 1126  *   // The created task will not run during this period, unless</div><div id="1127" class="line none"> 1127  *   // another task calls vTaskResume( xHandle ).</div><div id="1128" class="line none"> 1128  *</div><div id="1129" class="line none"> 1129  *   //...</div><div id="1130" class="line none"> 1130  *</div><div id="1131" class="line none"> 1131  *</div><div id="1132" class="line none"> 1132  *   // Suspend ourselves.</div><div id="1133" class="line none"> 1133  *   vTaskSuspend( NULL );</div><div id="1134" class="line none"> 1134  *</div><div id="1135" class="line none"> 1135  *   // We cannot get here unless another task calls vTaskResume</div><div id="1136" class="line none"> 1136  *   // with our handle as the parameter.</div><div id="1137" class="line none"> 1137  * }</div><div id="1138" class="line none"> 1138  * @endcode</div><div id="1139" class="line none"> 1139  * \defgroup vTaskSuspend vTaskSuspend</div><div id="1140" class="line none"> 1140  * \ingroup TaskCtrl</div><div id="1141" class="line none"> 1141  */</div><div id="1142" class="line none"> 1142 void vTaskSuspend( <a href="task.h.html#87">TaskHandle_t</a> xTaskToSuspend ) PRIVILEGED_FUNCTION;</div><div id="1143" class="line none"> 1143 </div><div id="1144" class="line none"> 1144 /**</div><div id="1145" class="line none"> 1145  * task. h</div><div id="1146" class="line none"> 1146  * @code{c}</div><div id="1147" class="line none"> 1147  * void vTaskResume( TaskHandle_t xTaskToResume );</div><div id="1148" class="line none"> 1148  * @endcode</div><div id="1149" class="line none"> 1149  *</div><div id="1150" class="line none"> 1150  * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.</div><div id="1151" class="line none"> 1151  * See the configuration section for more information.</div><div id="1152" class="line none"> 1152  *</div><div id="1153" class="line none"> 1153  * Resumes a suspended task.</div><div id="1154" class="line none"> 1154  *</div><div id="1155" class="line none"> 1155  * A task that has been suspended by one or more calls to vTaskSuspend ()</div><div id="1156" class="line none"> 1156  * will be made available for running again by a single call to</div><div id="1157" class="line none"> 1157  * vTaskResume ().</div><div id="1158" class="line none"> 1158  *</div><div id="1159" class="line none"> 1159  * @param xTaskToResume Handle to the task being readied.</div><div id="1160" class="line none"> 1160  *</div><div id="1161" class="line none"> 1161  * Example usage:</div><div id="1162" class="line none"> 1162  * @code{c}</div><div id="1163" class="line none"> 1163  * void vAFunction( void )</div><div id="1164" class="line none"> 1164  * {</div><div id="1165" class="line none"> 1165  * TaskHandle_t xHandle;</div><div id="1166" class="line none"> 1166  *</div><div id="1167" class="line none"> 1167  *   // Create a task, storing the handle.</div><div id="1168" class="line none"> 1168  *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &amp;xHandle );</div><div id="1169" class="line none"> 1169  *</div><div id="1170" class="line none"> 1170  *   // ...</div><div id="1171" class="line none"> 1171  *</div><div id="1172" class="line none"> 1172  *   // Use the handle to suspend the created task.</div><div id="1173" class="line none"> 1173  *   vTaskSuspend( xHandle );</div><div id="1174" class="line none"> 1174  *</div><div id="1175" class="line none"> 1175  *   // ...</div><div id="1176" class="line none"> 1176  *</div><div id="1177" class="line none"> 1177  *   // The created task will not run during this period, unless</div><div id="1178" class="line none"> 1178  *   // another task calls vTaskResume( xHandle ).</div><div id="1179" class="line none"> 1179  *</div><div id="1180" class="line none"> 1180  *   //...</div><div id="1181" class="line none"> 1181  *</div><div id="1182" class="line none"> 1182  *</div><div id="1183" class="line none"> 1183  *   // Resume the suspended task ourselves.</div><div id="1184" class="line none"> 1184  *   vTaskResume( xHandle );</div><div id="1185" class="line none"> 1185  *</div><div id="1186" class="line none"> 1186  *   // The created task will once again get microcontroller processing</div><div id="1187" class="line none"> 1187  *   // time in accordance with its priority within the system.</div><div id="1188" class="line none"> 1188  * }</div><div id="1189" class="line none"> 1189  * @endcode</div><div id="1190" class="line none"> 1190  * \defgroup vTaskResume vTaskResume</div><div id="1191" class="line none"> 1191  * \ingroup TaskCtrl</div><div id="1192" class="line none"> 1192  */</div><div id="1193" class="line none"> 1193 void vTaskResume( <a href="task.h.html#87">TaskHandle_t</a> xTaskToResume ) PRIVILEGED_FUNCTION;</div><div id="1194" class="line none"> 1194 </div><div id="1195" class="line none"> 1195 /**</div><div id="1196" class="line none"> 1196  * task. h</div><div id="1197" class="line none"> 1197  * @code{c}</div><div id="1198" class="line none"> 1198  * void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</div><div id="1199" class="line none"> 1199  * @endcode</div><div id="1200" class="line none"> 1200  *</div><div id="1201" class="line none"> 1201  * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be</div><div id="1202" class="line none"> 1202  * available.  See the configuration section for more information.</div><div id="1203" class="line none"> 1203  *</div><div id="1204" class="line none"> 1204  * An implementation of vTaskResume() that can be called from within an ISR.</div><div id="1205" class="line none"> 1205  *</div><div id="1206" class="line none"> 1206  * A task that has been suspended by one or more calls to vTaskSuspend ()</div><div id="1207" class="line none"> 1207  * will be made available for running again by a single call to</div><div id="1208" class="line none"> 1208  * xTaskResumeFromISR ().</div><div id="1209" class="line none"> 1209  *</div><div id="1210" class="line none"> 1210  * xTaskResumeFromISR() should not be used to synchronise a task with an</div><div id="1211" class="line none"> 1211  * interrupt if there is a chance that the interrupt could arrive prior to the</div><div id="1212" class="line none"> 1212  * task being suspended - as this can lead to interrupts being missed. Use of a</div><div id="1213" class="line none"> 1213  * semaphore as a synchronisation mechanism would avoid this eventuality.</div><div id="1214" class="line none"> 1214  *</div><div id="1215" class="line none"> 1215  * @param xTaskToResume Handle to the task being readied.</div><div id="1216" class="line none"> 1216  *</div><div id="1217" class="line none"> 1217  * @return pdTRUE if resuming the task should result in a context switch,</div><div id="1218" class="line none"> 1218  * otherwise pdFALSE. This is used by the ISR to determine if a context switch</div><div id="1219" class="line none"> 1219  * may be required following the ISR.</div><div id="1220" class="line none"> 1220  *</div><div id="1221" class="line none"> 1221  * \defgroup vTaskResumeFromISR vTaskResumeFromISR</div><div id="1222" class="line none"> 1222  * \ingroup TaskCtrl</div><div id="1223" class="line none"> 1223  */</div><div id="1224" class="line none"> 1224 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskResumeFromISR( <a href="task.h.html#87">TaskHandle_t</a> xTaskToResume ) PRIVILEGED_FUNCTION;</div><div id="1225" class="line none"> 1225 </div><div id="1226" class="line none"> 1226 /*-----------------------------------------------------------</div><div id="1227" class="line none"> 1227 * SCHEDULER CONTROL</div><div id="1228" class="line none"> 1228 *----------------------------------------------------------*/</div><div id="1229" class="line none"> 1229 </div><div id="1230" class="line none"> 1230 /**</div><div id="1231" class="line none"> 1231  * task. h</div><div id="1232" class="line none"> 1232  * @code{c}</div><div id="1233" class="line none"> 1233  * void vTaskStartScheduler( void );</div><div id="1234" class="line none"> 1234  * @endcode</div><div id="1235" class="line none"> 1235  *</div><div id="1236" class="line none"> 1236  * Starts the real time kernel tick processing.  After calling the kernel</div><div id="1237" class="line none"> 1237  * has control over which tasks are executed and when.</div><div id="1238" class="line none"> 1238  *</div><div id="1239" class="line none"> 1239  * See the demo application file main.c for an example of creating</div><div id="1240" class="line none"> 1240  * tasks and starting the kernel.</div><div id="1241" class="line none"> 1241  *</div><div id="1242" class="line none"> 1242  * Example usage:</div><div id="1243" class="line none"> 1243  * @code{c}</div><div id="1244" class="line none"> 1244  * void vAFunction( void )</div><div id="1245" class="line none"> 1245  * {</div><div id="1246" class="line none"> 1246  *   // Create at least one task before starting the kernel.</div><div id="1247" class="line none"> 1247  *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );</div><div id="1248" class="line none"> 1248  *</div><div id="1249" class="line none"> 1249  *   // Start the real time kernel with preemption.</div><div id="1250" class="line none"> 1250  *   vTaskStartScheduler ();</div><div id="1251" class="line none"> 1251  *</div><div id="1252" class="line none"> 1252  *   // Will not get here unless a task calls vTaskEndScheduler ()</div><div id="1253" class="line none"> 1253  * }</div><div id="1254" class="line none"> 1254  * @endcode</div><div id="1255" class="line none"> 1255  *</div><div id="1256" class="line none"> 1256  * \defgroup vTaskStartScheduler vTaskStartScheduler</div><div id="1257" class="line none"> 1257  * \ingroup SchedulerControl</div><div id="1258" class="line none"> 1258  */</div><div id="1259" class="line none"> 1259 void vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;</div><div id="1260" class="line none"> 1260 </div><div id="1261" class="line none"> 1261 /**</div><div id="1262" class="line none"> 1262  * task. h</div><div id="1263" class="line none"> 1263  * @code{c}</div><div id="1264" class="line none"> 1264  * void vTaskEndScheduler( void );</div><div id="1265" class="line none"> 1265  * @endcode</div><div id="1266" class="line none"> 1266  *</div><div id="1267" class="line none"> 1267  * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC</div><div id="1268" class="line none"> 1268  * in place of DOS, implements this function.</div><div id="1269" class="line none"> 1269  *</div><div id="1270" class="line none"> 1270  * Stops the real time kernel tick.  All created tasks will be automatically</div><div id="1271" class="line none"> 1271  * deleted and multitasking (either preemptive or cooperative) will</div><div id="1272" class="line none"> 1272  * stop.  Execution then resumes from the point where vTaskStartScheduler ()</div><div id="1273" class="line none"> 1273  * was called, as if vTaskStartScheduler () had just returned.</div><div id="1274" class="line none"> 1274  *</div><div id="1275" class="line none"> 1275  * See the demo application file main. c in the demo/PC directory for an</div><div id="1276" class="line none"> 1276  * example that uses vTaskEndScheduler ().</div><div id="1277" class="line none"> 1277  *</div><div id="1278" class="line none"> 1278  * vTaskEndScheduler () requires an exit function to be defined within the</div><div id="1279" class="line none"> 1279  * portable layer (see vPortEndScheduler () in port. c for the PC port).  This</div><div id="1280" class="line none"> 1280  * performs hardware specific operations such as stopping the kernel tick.</div><div id="1281" class="line none"> 1281  *</div><div id="1282" class="line none"> 1282  * vTaskEndScheduler () will cause all of the resources allocated by the</div><div id="1283" class="line none"> 1283  * kernel to be freed - but will not free resources allocated by application</div><div id="1284" class="line none"> 1284  * tasks.</div><div id="1285" class="line none"> 1285  *</div><div id="1286" class="line none"> 1286  * Example usage:</div><div id="1287" class="line none"> 1287  * @code{c}</div><div id="1288" class="line none"> 1288  * void vTaskCode( void * pvParameters )</div><div id="1289" class="line none"> 1289  * {</div><div id="1290" class="line none"> 1290  *   for( ;; )</div><div id="1291" class="line none"> 1291  *   {</div><div id="1292" class="line none"> 1292  *       // Task code goes here.</div><div id="1293" class="line none"> 1293  *</div><div id="1294" class="line none"> 1294  *       // At some point we want to end the real time kernel processing</div><div id="1295" class="line none"> 1295  *       // so call ...</div><div id="1296" class="line none"> 1296  *       vTaskEndScheduler ();</div><div id="1297" class="line none"> 1297  *   }</div><div id="1298" class="line none"> 1298  * }</div><div id="1299" class="line none"> 1299  *</div><div id="1300" class="line none"> 1300  * void vAFunction( void )</div><div id="1301" class="line none"> 1301  * {</div><div id="1302" class="line none"> 1302  *   // Create at least one task before starting the kernel.</div><div id="1303" class="line none"> 1303  *   xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );</div><div id="1304" class="line none"> 1304  *</div><div id="1305" class="line none"> 1305  *   // Start the real time kernel with preemption.</div><div id="1306" class="line none"> 1306  *   vTaskStartScheduler ();</div><div id="1307" class="line none"> 1307  *</div><div id="1308" class="line none"> 1308  *   // Will only get here when the vTaskCode () task has called</div><div id="1309" class="line none"> 1309  *   // vTaskEndScheduler ().  When we get here we are back to single task</div><div id="1310" class="line none"> 1310  *   // execution.</div><div id="1311" class="line none"> 1311  * }</div><div id="1312" class="line none"> 1312  * @endcode</div><div id="1313" class="line none"> 1313  *</div><div id="1314" class="line none"> 1314  * \defgroup vTaskEndScheduler vTaskEndScheduler</div><div id="1315" class="line none"> 1315  * \ingroup SchedulerControl</div><div id="1316" class="line none"> 1316  */</div><div id="1317" class="line none"> 1317 void vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;</div><div id="1318" class="line none"> 1318 </div><div id="1319" class="line none"> 1319 /**</div><div id="1320" class="line none"> 1320  * task. h</div><div id="1321" class="line none"> 1321  * @code{c}</div><div id="1322" class="line none"> 1322  * void vTaskSuspendAll( void );</div><div id="1323" class="line none"> 1323  * @endcode</div><div id="1324" class="line none"> 1324  *</div><div id="1325" class="line none"> 1325  * Suspends the scheduler without disabling interrupts.  Context switches will</div><div id="1326" class="line none"> 1326  * not occur while the scheduler is suspended.</div><div id="1327" class="line none"> 1327  *</div><div id="1328" class="line none"> 1328  * After calling vTaskSuspendAll () the calling task will continue to execute</div><div id="1329" class="line none"> 1329  * without risk of being swapped out until a call to xTaskResumeAll () has been</div><div id="1330" class="line none"> 1330  * made.</div><div id="1331" class="line none"> 1331  *</div><div id="1332" class="line none"> 1332  * API functions that have the potential to cause a context switch (for example,</div><div id="1333" class="line none"> 1333  * xTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler</div><div id="1334" class="line none"> 1334  * is suspended.</div><div id="1335" class="line none"> 1335  *</div><div id="1336" class="line none"> 1336  * Example usage:</div><div id="1337" class="line none"> 1337  * @code{c}</div><div id="1338" class="line none"> 1338  * void vTask1( void * pvParameters )</div><div id="1339" class="line none"> 1339  * {</div><div id="1340" class="line none"> 1340  *   for( ;; )</div><div id="1341" class="line none"> 1341  *   {</div><div id="1342" class="line none"> 1342  *       // Task code goes here.</div><div id="1343" class="line none"> 1343  *</div><div id="1344" class="line none"> 1344  *       // ...</div><div id="1345" class="line none"> 1345  *</div><div id="1346" class="line none"> 1346  *       // At some point the task wants to perform a long operation during</div><div id="1347" class="line none"> 1347  *       // which it does not want to get swapped out.  It cannot use</div><div id="1348" class="line none"> 1348  *       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the</div><div id="1349" class="line none"> 1349  *       // operation may cause interrupts to be missed - including the</div><div id="1350" class="line none"> 1350  *       // ticks.</div><div id="1351" class="line none"> 1351  *</div><div id="1352" class="line none"> 1352  *       // Prevent the real time kernel swapping out the task.</div><div id="1353" class="line none"> 1353  *       vTaskSuspendAll ();</div><div id="1354" class="line none"> 1354  *</div><div id="1355" class="line none"> 1355  *       // Perform the operation here.  There is no need to use critical</div><div id="1356" class="line none"> 1356  *       // sections as we have all the microcontroller processing time.</div><div id="1357" class="line none"> 1357  *       // During this time interrupts will still operate and the kernel</div><div id="1358" class="line none"> 1358  *       // tick count will be maintained.</div><div id="1359" class="line none"> 1359  *</div><div id="1360" class="line none"> 1360  *       // ...</div><div id="1361" class="line none"> 1361  *</div><div id="1362" class="line none"> 1362  *       // The operation is complete.  Restart the kernel.</div><div id="1363" class="line none"> 1363  *       xTaskResumeAll ();</div><div id="1364" class="line none"> 1364  *   }</div><div id="1365" class="line none"> 1365  * }</div><div id="1366" class="line none"> 1366  * @endcode</div><div id="1367" class="line none"> 1367  * \defgroup vTaskSuspendAll vTaskSuspendAll</div><div id="1368" class="line none"> 1368  * \ingroup SchedulerControl</div><div id="1369" class="line none"> 1369  */</div><div id="1370" class="line none"> 1370 void <a href="task.h.html#1370">vTaskSuspendAll</a>( void ) PRIVILEGED_FUNCTION;</div><div id="1371" class="line none"> 1371 </div><div id="1372" class="line none"> 1372 /**</div><div id="1373" class="line none"> 1373  * task. h</div><div id="1374" class="line none"> 1374  * @code{c}</div><div id="1375" class="line none"> 1375  * BaseType_t xTaskResumeAll( void );</div><div id="1376" class="line none"> 1376  * @endcode</div><div id="1377" class="line none"> 1377  *</div><div id="1378" class="line none"> 1378  * Resumes scheduler activity after it was suspended by a call to</div><div id="1379" class="line none"> 1379  * vTaskSuspendAll().</div><div id="1380" class="line none"> 1380  *</div><div id="1381" class="line none"> 1381  * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks</div><div id="1382" class="line none"> 1382  * that were previously suspended by a call to vTaskSuspend().</div><div id="1383" class="line none"> 1383  *</div><div id="1384" class="line none"> 1384  * @return If resuming the scheduler caused a context switch then pdTRUE is</div><div id="1385" class="line none"> 1385  *         returned, otherwise pdFALSE is returned.</div><div id="1386" class="line none"> 1386  *</div><div id="1387" class="line none"> 1387  * Example usage:</div><div id="1388" class="line none"> 1388  * @code{c}</div><div id="1389" class="line none"> 1389  * void vTask1( void * pvParameters )</div><div id="1390" class="line none"> 1390  * {</div><div id="1391" class="line none"> 1391  *   for( ;; )</div><div id="1392" class="line none"> 1392  *   {</div><div id="1393" class="line none"> 1393  *       // Task code goes here.</div><div id="1394" class="line none"> 1394  *</div><div id="1395" class="line none"> 1395  *       // ...</div><div id="1396" class="line none"> 1396  *</div><div id="1397" class="line none"> 1397  *       // At some point the task wants to perform a long operation during</div><div id="1398" class="line none"> 1398  *       // which it does not want to get swapped out.  It cannot use</div><div id="1399" class="line none"> 1399  *       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the</div><div id="1400" class="line none"> 1400  *       // operation may cause interrupts to be missed - including the</div><div id="1401" class="line none"> 1401  *       // ticks.</div><div id="1402" class="line none"> 1402  *</div><div id="1403" class="line none"> 1403  *       // Prevent the real time kernel swapping out the task.</div><div id="1404" class="line none"> 1404  *       vTaskSuspendAll ();</div><div id="1405" class="line none"> 1405  *</div><div id="1406" class="line none"> 1406  *       // Perform the operation here.  There is no need to use critical</div><div id="1407" class="line none"> 1407  *       // sections as we have all the microcontroller processing time.</div><div id="1408" class="line none"> 1408  *       // During this time interrupts will still operate and the real</div><div id="1409" class="line none"> 1409  *       // time kernel tick count will be maintained.</div><div id="1410" class="line none"> 1410  *</div><div id="1411" class="line none"> 1411  *       // ...</div><div id="1412" class="line none"> 1412  *</div><div id="1413" class="line none"> 1413  *       // The operation is complete.  Restart the kernel.  We want to force</div><div id="1414" class="line none"> 1414  *       // a context switch - but there is no point if resuming the scheduler</div><div id="1415" class="line none"> 1415  *       // caused a context switch already.</div><div id="1416" class="line none"> 1416  *       if( !xTaskResumeAll () )</div><div id="1417" class="line none"> 1417  *       {</div><div id="1418" class="line none"> 1418  *            taskYIELD ();</div><div id="1419" class="line none"> 1419  *       }</div><div id="1420" class="line none"> 1420  *   }</div><div id="1421" class="line none"> 1421  * }</div><div id="1422" class="line none"> 1422  * @endcode</div><div id="1423" class="line none"> 1423  * \defgroup xTaskResumeAll xTaskResumeAll</div><div id="1424" class="line none"> 1424  * \ingroup SchedulerControl</div><div id="1425" class="line none"> 1425  */</div><div id="1426" class="line none"> 1426 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> <a href="task.h.html#1426">xTaskResumeAll</a>( void ) PRIVILEGED_FUNCTION;</div><div id="1427" class="line none"> 1427 </div><div id="1428" class="line none"> 1428 /*-----------------------------------------------------------</div><div id="1429" class="line none"> 1429 * TASK UTILITIES</div><div id="1430" class="line none"> 1430 *----------------------------------------------------------*/</div><div id="1431" class="line none"> 1431 </div><div id="1432" class="line none"> 1432 /**</div><div id="1433" class="line none"> 1433  * task. h</div><div id="1434" class="line none"> 1434  * @code{c}</div><div id="1435" class="line none"> 1435  * TickType_t xTaskGetTickCount( void );</div><div id="1436" class="line none"> 1436  * @endcode</div><div id="1437" class="line none"> 1437  *</div><div id="1438" class="line none"> 1438  * @return The count of ticks since vTaskStartScheduler was called.</div><div id="1439" class="line none"> 1439  *</div><div id="1440" class="line none"> 1440  * \defgroup xTaskGetTickCount xTaskGetTickCount</div><div id="1441" class="line none"> 1441  * \ingroup TaskUtils</div><div id="1442" class="line none"> 1442  */</div><div id="1443" class="line none"> 1443 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;</div><div id="1444" class="line none"> 1444 </div><div id="1445" class="line none"> 1445 /**</div><div id="1446" class="line none"> 1446  * task. h</div><div id="1447" class="line none"> 1447  * @code{c}</div><div id="1448" class="line none"> 1448  * TickType_t xTaskGetTickCountFromISR( void );</div><div id="1449" class="line none"> 1449  * @endcode</div><div id="1450" class="line none"> 1450  *</div><div id="1451" class="line none"> 1451  * @return The count of ticks since vTaskStartScheduler was called.</div><div id="1452" class="line none"> 1452  *</div><div id="1453" class="line none"> 1453  * This is a version of xTaskGetTickCount() that is safe to be called from an</div><div id="1454" class="line none"> 1454  * ISR - provided that TickType_t is the natural word size of the</div><div id="1455" class="line none"> 1455  * microcontroller being used or interrupt nesting is either not supported or</div><div id="1456" class="line none"> 1456  * not being used.</div><div id="1457" class="line none"> 1457  *</div><div id="1458" class="line none"> 1458  * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR</div><div id="1459" class="line none"> 1459  * \ingroup TaskUtils</div><div id="1460" class="line none"> 1460  */</div><div id="1461" class="line none"> 1461 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;</div><div id="1462" class="line none"> 1462 </div><div id="1463" class="line none"> 1463 /**</div><div id="1464" class="line none"> 1464  * task. h</div><div id="1465" class="line none"> 1465  * @code{c}</div><div id="1466" class="line none"> 1466  * uint16_t uxTaskGetNumberOfTasks( void );</div><div id="1467" class="line none"> 1467  * @endcode</div><div id="1468" class="line none"> 1468  *</div><div id="1469" class="line none"> 1469  * @return The number of tasks that the real time kernel is currently managing.</div><div id="1470" class="line none"> 1470  * This includes all ready, blocked and suspended tasks.  A task that</div><div id="1471" class="line none"> 1471  * has been deleted but not yet freed by the idle task will also be</div><div id="1472" class="line none"> 1472  * included in the count.</div><div id="1473" class="line none"> 1473  *</div><div id="1474" class="line none"> 1474  * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks</div><div id="1475" class="line none"> 1475  * \ingroup TaskUtils</div><div id="1476" class="line none"> 1476  */</div><div id="1477" class="line none"> 1477 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;</div><div id="1478" class="line none"> 1478 </div><div id="1479" class="line none"> 1479 /**</div><div id="1480" class="line none"> 1480  * task. h</div><div id="1481" class="line none"> 1481  * @code{c}</div><div id="1482" class="line none"> 1482  * char *pcTaskGetName( TaskHandle_t xTaskToQuery );</div><div id="1483" class="line none"> 1483  * @endcode</div><div id="1484" class="line none"> 1484  *</div><div id="1485" class="line none"> 1485  * @return The text (human readable) name of the task referenced by the handle</div><div id="1486" class="line none"> 1486  * xTaskToQuery.  A task can query its own name by either passing in its own</div><div id="1487" class="line none"> 1487  * handle, or by setting xTaskToQuery to NULL.</div><div id="1488" class="line none"> 1488  *</div><div id="1489" class="line none"> 1489  * \defgroup pcTaskGetName pcTaskGetName</div><div id="1490" class="line none"> 1490  * \ingroup TaskUtils</div><div id="1491" class="line none"> 1491  */</div><div id="1492" class="line none"> 1492 char * pcTaskGetName( <a href="task.h.html#87">TaskHandle_t</a> xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */</div><div id="1493" class="line none"> 1493 </div><div id="1494" class="line none"> 1494 /**</div><div id="1495" class="line none"> 1495  * task. h</div><div id="1496" class="line none"> 1496  * @code{c}</div><div id="1497" class="line none"> 1497  * TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );</div><div id="1498" class="line none"> 1498  * @endcode</div><div id="1499" class="line none"> 1499  *</div><div id="1500" class="line none"> 1500  * NOTE:  This function takes a relatively long time to complete and should be</div><div id="1501" class="line none"> 1501  * used sparingly.</div><div id="1502" class="line none"> 1502  *</div><div id="1503" class="line none"> 1503  * @return The handle of the task that has the human readable name pcNameToQuery.</div><div id="1504" class="line none"> 1504  * NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle</div><div id="1505" class="line none"> 1505  * must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.</div><div id="1506" class="line none"> 1506  *</div><div id="1507" class="line none"> 1507  * \defgroup pcTaskGetHandle pcTaskGetHandle</div><div id="1508" class="line none"> 1508  * \ingroup TaskUtils</div><div id="1509" class="line none"> 1509  */</div><div id="1510" class="line none"> 1510 <a href="task.h.html#87">TaskHandle_t</a> xTaskGetHandle( const char * pcNameToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */</div><div id="1511" class="line none"> 1511 </div><div id="1512" class="line none"> 1512 /**</div><div id="1513" class="line none"> 1513  * task.h</div><div id="1514" class="line none"> 1514  * @code{c}</div><div id="1515" class="line none"> 1515  * UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</div><div id="1516" class="line none"> 1516  * @endcode</div><div id="1517" class="line none"> 1517  *</div><div id="1518" class="line none"> 1518  * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for</div><div id="1519" class="line none"> 1519  * this function to be available.</div><div id="1520" class="line none"> 1520  *</div><div id="1521" class="line none"> 1521  * Returns the high water mark of the stack associated with xTask.  That is,</div><div id="1522" class="line none"> 1522  * the minimum free stack space there has been (in words, so on a 32 bit machine</div><div id="1523" class="line none"> 1523  * a value of 1 means 4 bytes) since the task started.  The smaller the returned</div><div id="1524" class="line none"> 1524  * number the closer the task has come to overflowing its stack.</div><div id="1525" class="line none"> 1525  *</div><div id="1526" class="line none"> 1526  * uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the</div><div id="1527" class="line none"> 1527  * same except for their return type.  Using configSTACK_DEPTH_TYPE allows the</div><div id="1528" class="line none"> 1528  * user to determine the return type.  It gets around the problem of the value</div><div id="1529" class="line none"> 1529  * overflowing on 8-bit types without breaking backward compatibility for</div><div id="1530" class="line none"> 1530  * applications that expect an 8-bit return type.</div><div id="1531" class="line none"> 1531  *</div><div id="1532" class="line none"> 1532  * @param xTask Handle of the task associated with the stack to be checked.</div><div id="1533" class="line none"> 1533  * Set xTask to NULL to check the stack of the calling task.</div><div id="1534" class="line none"> 1534  *</div><div id="1535" class="line none"> 1535  * @return The smallest amount of free stack space there has been (in words, so</div><div id="1536" class="line none"> 1536  * actual spaces on the stack rather than bytes) since the task referenced by</div><div id="1537" class="line none"> 1537  * xTask was created.</div><div id="1538" class="line none"> 1538  */</div><div id="1539" class="line none"> 1539 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxTaskGetStackHighWaterMark( <a href="task.h.html#87">TaskHandle_t</a> xTask ) PRIVILEGED_FUNCTION;</div><div id="1540" class="line none"> 1540 </div><div id="1541" class="line none"> 1541 /**</div><div id="1542" class="line none"> 1542  * task.h</div><div id="1543" class="line none"> 1543  * @code{c}</div><div id="1544" class="line none"> 1544  * configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask );</div><div id="1545" class="line none"> 1545  * @endcode</div><div id="1546" class="line none"> 1546  *</div><div id="1547" class="line none"> 1547  * INCLUDE_uxTaskGetStackHighWaterMark2 must be set to 1 in FreeRTOSConfig.h for</div><div id="1548" class="line none"> 1548  * this function to be available.</div><div id="1549" class="line none"> 1549  *</div><div id="1550" class="line none"> 1550  * Returns the high water mark of the stack associated with xTask.  That is,</div><div id="1551" class="line none"> 1551  * the minimum free stack space there has been (in words, so on a 32 bit machine</div><div id="1552" class="line none"> 1552  * a value of 1 means 4 bytes) since the task started.  The smaller the returned</div><div id="1553" class="line none"> 1553  * number the closer the task has come to overflowing its stack.</div><div id="1554" class="line none"> 1554  *</div><div id="1555" class="line none"> 1555  * uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the</div><div id="1556" class="line none"> 1556  * same except for their return type.  Using configSTACK_DEPTH_TYPE allows the</div><div id="1557" class="line none"> 1557  * user to determine the return type.  It gets around the problem of the value</div><div id="1558" class="line none"> 1558  * overflowing on 8-bit types without breaking backward compatibility for</div><div id="1559" class="line none"> 1559  * applications that expect an 8-bit return type.</div><div id="1560" class="line none"> 1560  *</div><div id="1561" class="line none"> 1561  * @param xTask Handle of the task associated with the stack to be checked.</div><div id="1562" class="line none"> 1562  * Set xTask to NULL to check the stack of the calling task.</div><div id="1563" class="line none"> 1563  *</div><div id="1564" class="line none"> 1564  * @return The smallest amount of free stack space there has been (in words, so</div><div id="1565" class="line none"> 1565  * actual spaces on the stack rather than bytes) since the task referenced by</div><div id="1566" class="line none"> 1566  * xTask was created.</div><div id="1567" class="line none"> 1567  */</div><div id="1568" class="line none"> 1568 configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( <a href="task.h.html#87">TaskHandle_t</a> xTask ) PRIVILEGED_FUNCTION;</div><div id="1569" class="line none"> 1569 </div><div id="1570" class="line none"> 1570 /* When using trace macros it is sometimes necessary to include task.h before</div><div id="1571" class="line none"> 1571  * FreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,</div><div id="1572" class="line none"> 1572  * so the following two prototypes will cause a compilation error.  This can be</div><div id="1573" class="line none"> 1573  * fixed by simply guarding against the inclusion of these two prototypes unless</div><div id="1574" class="line none"> 1574  * they are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration</div><div id="1575" class="line none"> 1575  * constant. */</div><div id="1576" class="line none"> 1576 #ifdef configUSE_APPLICATION_TASK_TAG</div><div id="1577" class="line none"> 1577     #if configUSE_APPLICATION_TASK_TAG == 1</div><div id="1578" class="line none"> 1578 </div><div id="1579" class="line none"> 1579 /**</div><div id="1580" class="line none"> 1580  * task.h</div><div id="1581" class="line none"> 1581  * @code{c}</div><div id="1582" class="line none"> 1582  * void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );</div><div id="1583" class="line none"> 1583  * @endcode</div><div id="1584" class="line none"> 1584  *</div><div id="1585" class="line none"> 1585  * Sets pxHookFunction to be the task hook function used by the task xTask.</div><div id="1586" class="line none"> 1586  * Passing xTask as NULL has the effect of setting the calling tasks hook</div><div id="1587" class="line none"> 1587  * function.</div><div id="1588" class="line none"> 1588  */</div><div id="1589" class="line none"> 1589         void vTaskSetApplicationTaskTag( <a href="task.h.html#87">TaskHandle_t</a> xTask,</div><div id="1590" class="line none"> 1590                                          <a href="task.h.html#93">TaskHookFunction_t</a> pxHookFunction ) PRIVILEGED_FUNCTION;</div><div id="1591" class="line none"> 1591 </div><div id="1592" class="line none"> 1592 /**</div><div id="1593" class="line none"> 1593  * task.h</div><div id="1594" class="line none"> 1594  * @code{c}</div><div id="1595" class="line none"> 1595  * void xTaskGetApplicationTaskTag( TaskHandle_t xTask );</div><div id="1596" class="line none"> 1596  * @endcode</div><div id="1597" class="line none"> 1597  *</div><div id="1598" class="line none"> 1598  * Returns the pxHookFunction value assigned to the task xTask.  Do not</div><div id="1599" class="line none"> 1599  * call from an interrupt service routine - call</div><div id="1600" class="line none"> 1600  * xTaskGetApplicationTaskTagFromISR() instead.</div><div id="1601" class="line none"> 1601  */</div><div id="1602" class="line none"> 1602         <a href="task.h.html#93">TaskHookFunction_t</a> xTaskGetApplicationTaskTag( <a href="task.h.html#87">TaskHandle_t</a> xTask ) PRIVILEGED_FUNCTION;</div><div id="1603" class="line none"> 1603 </div><div id="1604" class="line none"> 1604 /**</div><div id="1605" class="line none"> 1605  * task.h</div><div id="1606" class="line none"> 1606  * @code{c}</div><div id="1607" class="line none"> 1607  * void xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask );</div><div id="1608" class="line none"> 1608  * @endcode</div><div id="1609" class="line none"> 1609  *</div><div id="1610" class="line none"> 1610  * Returns the pxHookFunction value assigned to the task xTask.  Can</div><div id="1611" class="line none"> 1611  * be called from an interrupt service routine.</div><div id="1612" class="line none"> 1612  */</div><div id="1613" class="line none"> 1613         <a href="task.h.html#93">TaskHookFunction_t</a> xTaskGetApplicationTaskTagFromISR( <a href="task.h.html#87">TaskHandle_t</a> xTask ) PRIVILEGED_FUNCTION;</div><div id="1614" class="line none"> 1614     #endif /* configUSE_APPLICATION_TASK_TAG ==1 */</div><div id="1615" class="line none"> 1615 #endif /* ifdef configUSE_APPLICATION_TASK_TAG */</div><div id="1616" class="line none"> 1616 </div><div id="1617" class="line none"> 1617 #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )</div><div id="1618" class="line none"> 1618 </div><div id="1619" class="line none"> 1619 /* Each task contains an array of pointers that is dimensioned by the</div><div id="1620" class="line none"> 1620  * configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The</div><div id="1621" class="line none"> 1621  * kernel does not use the pointers itself, so the application writer can use</div><div id="1622" class="line none"> 1622  * the pointers for any purpose they wish.  The following two functions are</div><div id="1623" class="line none"> 1623  * used to set and query a pointer respectively. */</div><div id="1624" class="line none"> 1624     void vTaskSetThreadLocalStoragePointer( <a href="task.h.html#87">TaskHandle_t</a> xTaskToSet,</div><div id="1625" class="line none"> 1625                                             <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xIndex,</div><div id="1626" class="line none"> 1626                                             void * pvValue ) PRIVILEGED_FUNCTION;</div><div id="1627" class="line none"> 1627     void * pvTaskGetThreadLocalStoragePointer( <a href="task.h.html#87">TaskHandle_t</a> xTaskToQuery,</div><div id="1628" class="line none"> 1628                                                <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xIndex ) PRIVILEGED_FUNCTION;</div><div id="1629" class="line none"> 1629 </div><div id="1630" class="line none"> 1630 #endif</div><div id="1631" class="line none"> 1631 </div><div id="1632" class="line none"> 1632 #if ( configCHECK_FOR_STACK_OVERFLOW &gt; 0 )</div><div id="1633" class="line none"> 1633 </div><div id="1634" class="line none"> 1634 /**</div><div id="1635" class="line none"> 1635  * task.h</div><div id="1636" class="line none"> 1636  * @code{c}</div><div id="1637" class="line none"> 1637  * void vApplicationStackOverflowHook( TaskHandle_t xTask char *pcTaskName);</div><div id="1638" class="line none"> 1638  * @endcode</div><div id="1639" class="line none"> 1639  *</div><div id="1640" class="line none"> 1640  * The application stack overflow hook is called when a stack overflow is detected for a task.</div><div id="1641" class="line none"> 1641  *</div><div id="1642" class="line none"> 1642  * Details on stack overflow detection can be found here: https://www.FreeRTOS.org/Stacks-and-stack-overflow-checking.html</div><div id="1643" class="line none"> 1643  *</div><div id="1644" class="line none"> 1644  * @param xTask the task that just exceeded its stack boundaries.</div><div id="1645" class="line none"> 1645  * @param pcTaskName A character string containing the name of the offending task.</div><div id="1646" class="line none"> 1646  */</div><div id="1647" class="line none"> 1647     void vApplicationStackOverflowHook( <a href="task.h.html#87">TaskHandle_t</a> xTask,</div><div id="1648" class="line none"> 1648                                         char * <a href="task.h.html#157">pcTaskName</a> );</div><div id="1649" class="line none"> 1649 </div><div id="1650" class="line none"> 1650 #endif</div><div id="1651" class="line none"> 1651 </div><div id="1652" class="line none"> 1652 #if  ( configUSE_TICK_HOOK &gt; 0 )</div><div id="1653" class="line none"> 1653 </div><div id="1654" class="line none"> 1654 /**</div><div id="1655" class="line none"> 1655  *  task.h</div><div id="1656" class="line none"> 1656  * @code{c}</div><div id="1657" class="line none"> 1657  * void vApplicationTickHook( void );</div><div id="1658" class="line none"> 1658  * @endcode</div><div id="1659" class="line none"> 1659  *</div><div id="1660" class="line none"> 1660  * This hook function is called in the system tick handler after any OS work is completed.</div><div id="1661" class="line none"> 1661  */</div><div id="1662" class="line none"> 1662     void vApplicationTickHook( void ); /*lint !e526 Symbol not defined as it is an application callback. */</div><div id="1663" class="line none"> 1663 </div><div id="1664" class="line none"> 1664 #endif</div><div id="1665" class="line none"> 1665 </div><div id="1666" class="line none"> 1666 #if ( configSUPPORT_STATIC_ALLOCATION == 1 )</div><div id="1667" class="line none"> 1667 </div><div id="1668" class="line none"> 1668 /**</div><div id="1669" class="line none"> 1669  * task.h</div><div id="1670" class="line none"> 1670  * @code{c}</div><div id="1671" class="line none"> 1671  * void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer, StackType_t ** ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )</div><div id="1672" class="line none"> 1672  * @endcode</div><div id="1673" class="line none"> 1673  *</div><div id="1674" class="line none"> 1674  * This function is used to provide a statically allocated block of memory to FreeRTOS to hold the Idle Task TCB.  This function is required when</div><div id="1675" class="line none"> 1675  * configSUPPORT_STATIC_ALLOCATION is set.  For more information see this URI: https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION</div><div id="1676" class="line none"> 1676  *</div><div id="1677" class="line none"> 1677  * @param ppxIdleTaskTCBBuffer A handle to a statically allocated TCB buffer</div><div id="1678" class="line none"> 1678  * @param ppxIdleTaskStackBuffer A handle to a statically allocated Stack buffer for the idle task</div><div id="1679" class="line none"> 1679  * @param pulIdleTaskStackSize A pointer to the number of elements that will fit in the allocated stack buffer</div><div id="1680" class="line none"> 1680  */</div><div id="1681" class="line none"> 1681     void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer,</div><div id="1682" class="line none"> 1682                                         <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#59">StackType_t</a> ** ppxIdleTaskStackBuffer,</div><div id="1683" class="line none"> 1683                                         uint32_t * pulIdleTaskStackSize ); /*lint !e526 Symbol not defined as it is an application callback. */</div><div id="1684" class="line none"> 1684 #endif</div><div id="1685" class="line none"> 1685 </div><div id="1686" class="line none"> 1686 /**</div><div id="1687" class="line none"> 1687  * task.h</div><div id="1688" class="line none"> 1688  * @code{c}</div><div id="1689" class="line none"> 1689  * BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</div><div id="1690" class="line none"> 1690  * @endcode</div><div id="1691" class="line none"> 1691  *</div><div id="1692" class="line none"> 1692  * Calls the hook function associated with xTask.  Passing xTask as NULL has</div><div id="1693" class="line none"> 1693  * the effect of calling the Running tasks (the calling task) hook function.</div><div id="1694" class="line none"> 1694  *</div><div id="1695" class="line none"> 1695  * pvParameter is passed to the hook function for the task to interpret as it</div><div id="1696" class="line none"> 1696  * wants.  The return value is the value returned by the task hook function</div><div id="1697" class="line none"> 1697  * registered by the user.</div><div id="1698" class="line none"> 1698  */</div><div id="1699" class="line none"> 1699 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskCallApplicationTaskHook( <a href="task.h.html#87">TaskHandle_t</a> xTask,</div><div id="1700" class="line none"> 1700                                          void * pvParameter ) PRIVILEGED_FUNCTION;</div><div id="1701" class="line none"> 1701 </div><div id="1702" class="line none"> 1702 /**</div><div id="1703" class="line none"> 1703  * xTaskGetIdleTaskHandle() is only available if</div><div id="1704" class="line none"> 1704  * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.</div><div id="1705" class="line none"> 1705  *</div><div id="1706" class="line none"> 1706  * Simply returns the handle of the idle task.  It is not valid to call</div><div id="1707" class="line none"> 1707  * xTaskGetIdleTaskHandle() before the scheduler has been started.</div><div id="1708" class="line none"> 1708  */</div><div id="1709" class="line none"> 1709 <a href="task.h.html#87">TaskHandle_t</a> xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;</div><div id="1710" class="line none"> 1710 </div><div id="1711" class="line none"> 1711 /**</div><div id="1712" class="line none"> 1712  * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for</div><div id="1713" class="line none"> 1713  * uxTaskGetSystemState() to be available.</div><div id="1714" class="line none"> 1714  *</div><div id="1715" class="line none"> 1715  * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in</div><div id="1716" class="line none"> 1716  * the system.  TaskStatus_t structures contain, among other things, members</div><div id="1717" class="line none"> 1717  * for the task handle, task name, task priority, task state, and total amount</div><div id="1718" class="line none"> 1718  * of run time consumed by the task.  See the TaskStatus_t structure</div><div id="1719" class="line none"> 1719  * definition in this file for the full member list.</div><div id="1720" class="line none"> 1720  *</div><div id="1721" class="line none"> 1721  * NOTE:  This function is intended for debugging use only as its use results in</div><div id="1722" class="line none"> 1722  * the scheduler remaining suspended for an extended period.</div><div id="1723" class="line none"> 1723  *</div><div id="1724" class="line none"> 1724  * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.</div><div id="1725" class="line none"> 1725  * The array must contain at least one TaskStatus_t structure for each task</div><div id="1726" class="line none"> 1726  * that is under the control of the RTOS.  The number of tasks under the control</div><div id="1727" class="line none"> 1727  * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.</div><div id="1728" class="line none"> 1728  *</div><div id="1729" class="line none"> 1729  * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray</div><div id="1730" class="line none"> 1730  * parameter.  The size is specified as the number of indexes in the array, or</div><div id="1731" class="line none"> 1731  * the number of TaskStatus_t structures contained in the array, not by the</div><div id="1732" class="line none"> 1732  * number of bytes in the array.</div><div id="1733" class="line none"> 1733  *</div><div id="1734" class="line none"> 1734  * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in</div><div id="1735" class="line none"> 1735  * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the</div><div id="1736" class="line none"> 1736  * total run time (as defined by the run time stats clock, see</div><div id="1737" class="line none"> 1737  * https://www.FreeRTOS.org/rtos-run-time-stats.html) since the target booted.</div><div id="1738" class="line none"> 1738  * pulTotalRunTime can be set to NULL to omit the total run time information.</div><div id="1739" class="line none"> 1739  *</div><div id="1740" class="line none"> 1740  * @return The number of TaskStatus_t structures that were populated by</div><div id="1741" class="line none"> 1741  * uxTaskGetSystemState().  This should equal the number returned by the</div><div id="1742" class="line none"> 1742  * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed</div><div id="1743" class="line none"> 1743  * in the uxArraySize parameter was too small.</div><div id="1744" class="line none"> 1744  *</div><div id="1745" class="line none"> 1745  * Example usage:</div><div id="1746" class="line none"> 1746  * @code{c}</div><div id="1747" class="line none"> 1747  *  // This example demonstrates how a human readable table of run time stats</div><div id="1748" class="line none"> 1748  *  // information is generated from raw data provided by uxTaskGetSystemState().</div><div id="1749" class="line none"> 1749  *  // The human readable table is written to pcWriteBuffer</div><div id="1750" class="line none"> 1750  *  void vTaskGetRunTimeStats( char *pcWriteBuffer )</div><div id="1751" class="line none"> 1751  *  {</div><div id="1752" class="line none"> 1752  *  TaskStatus_t *pxTaskStatusArray;</div><div id="1753" class="line none"> 1753  *  volatile UBaseType_t uxArraySize, x;</div><div id="1754" class="line none"> 1754  *  configRUN_TIME_COUNTER_TYPE ulTotalRunTime, ulStatsAsPercentage;</div><div id="1755" class="line none"> 1755  *</div><div id="1756" class="line none"> 1756  *      // Make sure the write buffer does not contain a string.</div><div id="1757" class="line none"> 1757  * pcWriteBuffer = 0x00;</div><div id="1758" class="line none"> 1758  *</div><div id="1759" class="line none"> 1759  *      // Take a snapshot of the number of tasks in case it changes while this</div><div id="1760" class="line none"> 1760  *      // function is executing.</div><div id="1761" class="line none"> 1761  *      uxArraySize = uxTaskGetNumberOfTasks();</div><div id="1762" class="line none"> 1762  *</div><div id="1763" class="line none"> 1763  *      // Allocate a TaskStatus_t structure for each task.  An array could be</div><div id="1764" class="line none"> 1764  *      // allocated statically at compile time.</div><div id="1765" class="line none"> 1765  *      pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );</div><div id="1766" class="line none"> 1766  *</div><div id="1767" class="line none"> 1767  *      if( pxTaskStatusArray != NULL )</div><div id="1768" class="line none"> 1768  *      {</div><div id="1769" class="line none"> 1769  *          // Generate raw status information about each task.</div><div id="1770" class="line none"> 1770  *          uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &amp;ulTotalRunTime );</div><div id="1771" class="line none"> 1771  *</div><div id="1772" class="line none"> 1772  *          // For percentage calculations.</div><div id="1773" class="line none"> 1773  *          ulTotalRunTime /= 100UL;</div><div id="1774" class="line none"> 1774  *</div><div id="1775" class="line none"> 1775  *          // Avoid divide by zero errors.</div><div id="1776" class="line none"> 1776  *          if( ulTotalRunTime &gt; 0 )</div><div id="1777" class="line none"> 1777  *          {</div><div id="1778" class="line none"> 1778  *              // For each populated position in the pxTaskStatusArray array,</div><div id="1779" class="line none"> 1779  *              // format the raw data as human readable ASCII data</div><div id="1780" class="line none"> 1780  *              for( x = 0; x &lt; uxArraySize; x++ )</div><div id="1781" class="line none"> 1781  *              {</div><div id="1782" class="line none"> 1782  *                  // What percentage of the total run time has the task used?</div><div id="1783" class="line none"> 1783  *                  // This will always be rounded down to the nearest integer.</div><div id="1784" class="line none"> 1784  *                  // ulTotalRunTimeDiv100 has already been divided by 100.</div><div id="1785" class="line none"> 1785  *                  ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;</div><div id="1786" class="line none"> 1786  *</div><div id="1787" class="line none"> 1787  *                  if( ulStatsAsPercentage &gt; 0UL )</div><div id="1788" class="line none"> 1788  *                  {</div><div id="1789" class="line none"> 1789  *                      sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );</div><div id="1790" class="line none"> 1790  *                  }</div><div id="1791" class="line none"> 1791  *                  else</div><div id="1792" class="line none"> 1792  *                  {</div><div id="1793" class="line none"> 1793  *                      // If the percentage is zero here then the task has</div><div id="1794" class="line none"> 1794  *                      // consumed less than 1% of the total run time.</div><div id="1795" class="line none"> 1795  *                      sprintf( pcWriteBuffer, "%s\t\t%lu\t\t&lt;1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );</div><div id="1796" class="line none"> 1796  *                  }</div><div id="1797" class="line none"> 1797  *</div><div id="1798" class="line none"> 1798  *                  pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );</div><div id="1799" class="line none"> 1799  *              }</div><div id="1800" class="line none"> 1800  *          }</div><div id="1801" class="line none"> 1801  *</div><div id="1802" class="line none"> 1802  *          // The array is no longer needed, free the memory it consumes.</div><div id="1803" class="line none"> 1803  *          vPortFree( pxTaskStatusArray );</div><div id="1804" class="line none"> 1804  *      }</div><div id="1805" class="line none"> 1805  *  }</div><div id="1806" class="line none"> 1806  *  @endcode</div><div id="1807" class="line none"> 1807  */</div><div id="1808" class="line none"> 1808 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxTaskGetSystemState( <a href="task.h.html#169">TaskStatus_t</a> * const pxTaskStatusArray,</div><div id="1809" class="line none"> 1809                                   const <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxArraySize,</div><div id="1810" class="line none"> 1810                                   configRUN_TIME_COUNTER_TYPE * const pulTotalRunTime ) PRIVILEGED_FUNCTION;</div><div id="1811" class="line none"> 1811 </div><div id="1812" class="line none"> 1812 /**</div><div id="1813" class="line none"> 1813  * task. h</div><div id="1814" class="line none"> 1814  * @code{c}</div><div id="1815" class="line none"> 1815  * void vTaskList( char *pcWriteBuffer );</div><div id="1816" class="line none"> 1816  * @endcode</div><div id="1817" class="line none"> 1817  *</div><div id="1818" class="line none"> 1818  * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must</div><div id="1819" class="line none"> 1819  * both be defined as 1 for this function to be available.  See the</div><div id="1820" class="line none"> 1820  * configuration section of the FreeRTOS.org website for more information.</div><div id="1821" class="line none"> 1821  *</div><div id="1822" class="line none"> 1822  * NOTE 1: This function will disable interrupts for its duration.  It is</div><div id="1823" class="line none"> 1823  * not intended for normal application runtime use but as a debug aid.</div><div id="1824" class="line none"> 1824  *</div><div id="1825" class="line none"> 1825  * Lists all the current tasks, along with their current state and stack</div><div id="1826" class="line none"> 1826  * usage high water mark.</div><div id="1827" class="line none"> 1827  *</div><div id="1828" class="line none"> 1828  * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or</div><div id="1829" class="line none"> 1829  * suspended ('S').</div><div id="1830" class="line none"> 1830  *</div><div id="1831" class="line none"> 1831  * PLEASE NOTE:</div><div id="1832" class="line none"> 1832  *</div><div id="1833" class="line none"> 1833  * This function is provided for convenience only, and is used by many of the</div><div id="1834" class="line none"> 1834  * demo applications.  Do not consider it to be part of the scheduler.</div><div id="1835" class="line none"> 1835  *</div><div id="1836" class="line none"> 1836  * vTaskList() calls uxTaskGetSystemState(), then formats part of the</div><div id="1837" class="line none"> 1837  * uxTaskGetSystemState() output into a human readable table that displays task:</div><div id="1838" class="line none"> 1838  * names, states, priority, stack usage and task number.</div><div id="1839" class="line none"> 1839  * Stack usage specified as the number of unused StackType_t words stack can hold</div><div id="1840" class="line none"> 1840  * on top of stack - not the number of bytes.</div><div id="1841" class="line none"> 1841  *</div><div id="1842" class="line none"> 1842  * vTaskList() has a dependency on the sprintf() C library function that might</div><div id="1843" class="line none"> 1843  * bloat the code size, use a lot of stack, and provide different results on</div><div id="1844" class="line none"> 1844  * different platforms.  An alternative, tiny, third party, and limited</div><div id="1845" class="line none"> 1845  * functionality implementation of sprintf() is provided in many of the</div><div id="1846" class="line none"> 1846  * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note</div><div id="1847" class="line none"> 1847  * printf-stdarg.c does not provide a full snprintf() implementation!).</div><div id="1848" class="line none"> 1848  *</div><div id="1849" class="line none"> 1849  * It is recommended that production systems call uxTaskGetSystemState()</div><div id="1850" class="line none"> 1850  * directly to get access to raw stats data, rather than indirectly through a</div><div id="1851" class="line none"> 1851  * call to vTaskList().</div><div id="1852" class="line none"> 1852  *</div><div id="1853" class="line none"> 1853  * @param pcWriteBuffer A buffer into which the above mentioned details</div><div id="1854" class="line none"> 1854  * will be written, in ASCII form.  This buffer is assumed to be large</div><div id="1855" class="line none"> 1855  * enough to contain the generated report.  Approximately 40 bytes per</div><div id="1856" class="line none"> 1856  * task should be sufficient.</div><div id="1857" class="line none"> 1857  *</div><div id="1858" class="line none"> 1858  * \defgroup vTaskList vTaskList</div><div id="1859" class="line none"> 1859  * \ingroup TaskUtils</div><div id="1860" class="line none"> 1860  */</div><div id="1861" class="line none"> 1861 void vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */</div><div id="1862" class="line none"> 1862 </div><div id="1863" class="line none"> 1863 /**</div><div id="1864" class="line none"> 1864  * task. h</div><div id="1865" class="line none"> 1865  * @code{c}</div><div id="1866" class="line none"> 1866  * void vTaskGetRunTimeStats( char *pcWriteBuffer );</div><div id="1867" class="line none"> 1867  * @endcode</div><div id="1868" class="line none"> 1868  *</div><div id="1869" class="line none"> 1869  * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS</div><div id="1870" class="line none"> 1870  * must both be defined as 1 for this function to be available.  The application</div><div id="1871" class="line none"> 1871  * must also then provide definitions for</div><div id="1872" class="line none"> 1872  * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()</div><div id="1873" class="line none"> 1873  * to configure a peripheral timer/counter and return the timers current count</div><div id="1874" class="line none"> 1874  * value respectively.  The counter should be at least 10 times the frequency of</div><div id="1875" class="line none"> 1875  * the tick count.</div><div id="1876" class="line none"> 1876  *</div><div id="1877" class="line none"> 1877  * NOTE 1: This function will disable interrupts for its duration.  It is</div><div id="1878" class="line none"> 1878  * not intended for normal application runtime use but as a debug aid.</div><div id="1879" class="line none"> 1879  *</div><div id="1880" class="line none"> 1880  * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total</div><div id="1881" class="line none"> 1881  * accumulated execution time being stored for each task.  The resolution</div><div id="1882" class="line none"> 1882  * of the accumulated time value depends on the frequency of the timer</div><div id="1883" class="line none"> 1883  * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.</div><div id="1884" class="line none"> 1884  * Calling vTaskGetRunTimeStats() writes the total execution time of each</div><div id="1885" class="line none"> 1885  * task into a buffer, both as an absolute count value and as a percentage</div><div id="1886" class="line none"> 1886  * of the total system execution time.</div><div id="1887" class="line none"> 1887  *</div><div id="1888" class="line none"> 1888  * NOTE 2:</div><div id="1889" class="line none"> 1889  *</div><div id="1890" class="line none"> 1890  * This function is provided for convenience only, and is used by many of the</div><div id="1891" class="line none"> 1891  * demo applications.  Do not consider it to be part of the scheduler.</div><div id="1892" class="line none"> 1892  *</div><div id="1893" class="line none"> 1893  * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the</div><div id="1894" class="line none"> 1894  * uxTaskGetSystemState() output into a human readable table that displays the</div><div id="1895" class="line none"> 1895  * amount of time each task has spent in the Running state in both absolute and</div><div id="1896" class="line none"> 1896  * percentage terms.</div><div id="1897" class="line none"> 1897  *</div><div id="1898" class="line none"> 1898  * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function</div><div id="1899" class="line none"> 1899  * that might bloat the code size, use a lot of stack, and provide different</div><div id="1900" class="line none"> 1900  * results on different platforms.  An alternative, tiny, third party, and</div><div id="1901" class="line none"> 1901  * limited functionality implementation of sprintf() is provided in many of the</div><div id="1902" class="line none"> 1902  * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note</div><div id="1903" class="line none"> 1903  * printf-stdarg.c does not provide a full snprintf() implementation!).</div><div id="1904" class="line none"> 1904  *</div><div id="1905" class="line none"> 1905  * It is recommended that production systems call uxTaskGetSystemState() directly</div><div id="1906" class="line none"> 1906  * to get access to raw stats data, rather than indirectly through a call to</div><div id="1907" class="line none"> 1907  * vTaskGetRunTimeStats().</div><div id="1908" class="line none"> 1908  *</div><div id="1909" class="line none"> 1909  * @param pcWriteBuffer A buffer into which the execution times will be</div><div id="1910" class="line none"> 1910  * written, in ASCII form.  This buffer is assumed to be large enough to</div><div id="1911" class="line none"> 1911  * contain the generated report.  Approximately 40 bytes per task should</div><div id="1912" class="line none"> 1912  * be sufficient.</div><div id="1913" class="line none"> 1913  *</div><div id="1914" class="line none"> 1914  * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats</div><div id="1915" class="line none"> 1915  * \ingroup TaskUtils</div><div id="1916" class="line none"> 1916  */</div><div id="1917" class="line none"> 1917 void vTaskGetRunTimeStats( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */</div><div id="1918" class="line none"> 1918 </div><div id="1919" class="line none"> 1919 /**</div><div id="1920" class="line none"> 1920  * task. h</div><div id="1921" class="line none"> 1921  * @code{c}</div><div id="1922" class="line none"> 1922  * configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimeCounter( void );</div><div id="1923" class="line none"> 1923  * configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimePercent( void );</div><div id="1924" class="line none"> 1924  * @endcode</div><div id="1925" class="line none"> 1925  *</div><div id="1926" class="line none"> 1926  * configGENERATE_RUN_TIME_STATS, configUSE_STATS_FORMATTING_FUNCTIONS and</div><div id="1927" class="line none"> 1927  * INCLUDE_xTaskGetIdleTaskHandle must all be defined as 1 for these functions</div><div id="1928" class="line none"> 1928  * to be available.  The application must also then provide definitions for</div><div id="1929" class="line none"> 1929  * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()</div><div id="1930" class="line none"> 1930  * to configure a peripheral timer/counter and return the timers current count</div><div id="1931" class="line none"> 1931  * value respectively.  The counter should be at least 10 times the frequency of</div><div id="1932" class="line none"> 1932  * the tick count.</div><div id="1933" class="line none"> 1933  *</div><div id="1934" class="line none"> 1934  * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total</div><div id="1935" class="line none"> 1935  * accumulated execution time being stored for each task.  The resolution</div><div id="1936" class="line none"> 1936  * of the accumulated time value depends on the frequency of the timer</div><div id="1937" class="line none"> 1937  * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.</div><div id="1938" class="line none"> 1938  * While uxTaskGetSystemState() and vTaskGetRunTimeStats() writes the total</div><div id="1939" class="line none"> 1939  * execution time of each task into a buffer, ulTaskGetIdleRunTimeCounter()</div><div id="1940" class="line none"> 1940  * returns the total execution time of just the idle task and</div><div id="1941" class="line none"> 1941  * ulTaskGetIdleRunTimePercent() returns the percentage of the CPU time used by</div><div id="1942" class="line none"> 1942  * just the idle task.</div><div id="1943" class="line none"> 1943  *</div><div id="1944" class="line none"> 1944  * Note the amount of idle time is only a good measure of the slack time in a</div><div id="1945" class="line none"> 1945  * system if there are no other tasks executing at the idle priority, tickless</div><div id="1946" class="line none"> 1946  * idle is not used, and configIDLE_SHOULD_YIELD is set to 0.</div><div id="1947" class="line none"> 1947  *</div><div id="1948" class="line none"> 1948  * @return The total run time of the idle task or the percentage of the total</div><div id="1949" class="line none"> 1949  * run time consumed by the idle task.  This is the amount of time the</div><div id="1950" class="line none"> 1950  * idle task has actually been executing.  The unit of time is dependent on the</div><div id="1951" class="line none"> 1951  * frequency configured using the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and</div><div id="1952" class="line none"> 1952  * portGET_RUN_TIME_COUNTER_VALUE() macros.</div><div id="1953" class="line none"> 1953  *</div><div id="1954" class="line none"> 1954  * \defgroup ulTaskGetIdleRunTimeCounter ulTaskGetIdleRunTimeCounter</div><div id="1955" class="line none"> 1955  * \ingroup TaskUtils</div><div id="1956" class="line none"> 1956  */</div><div id="1957" class="line none"> 1957 configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimeCounter( void ) PRIVILEGED_FUNCTION;</div><div id="1958" class="line none"> 1958 configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimePercent( void ) PRIVILEGED_FUNCTION;</div><div id="1959" class="line none"> 1959 </div><div id="1960" class="line none"> 1960 /**</div><div id="1961" class="line none"> 1961  * task. h</div><div id="1962" class="line none"> 1962  * @code{c}</div><div id="1963" class="line none"> 1963  * BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction );</div><div id="1964" class="line none"> 1964  * BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</div><div id="1965" class="line none"> 1965  * @endcode</div><div id="1966" class="line none"> 1966  *</div><div id="1967" class="line none"> 1967  * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.</div><div id="1968" class="line none"> 1968  *</div><div id="1969" class="line none"> 1969  * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these</div><div id="1970" class="line none"> 1970  * functions to be available.</div><div id="1971" class="line none"> 1971  *</div><div id="1972" class="line none"> 1972  * Sends a direct to task notification to a task, with an optional value and</div><div id="1973" class="line none"> 1973  * action.</div><div id="1974" class="line none"> 1974  *</div><div id="1975" class="line none"> 1975  * Each task has a private array of "notification values" (or 'notifications'),</div><div id="1976" class="line none"> 1976  * each of which is a 32-bit unsigned integer (uint32_t).  The constant</div><div id="1977" class="line none"> 1977  * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the</div><div id="1978" class="line none"> 1978  * array, and (for backward compatibility) defaults to 1 if left undefined.</div><div id="1979" class="line none"> 1979  * Prior to FreeRTOS V10.4.0 there was only one notification value per task.</div><div id="1980" class="line none"> 1980  *</div><div id="1981" class="line none"> 1981  * Events can be sent to a task using an intermediary object.  Examples of such</div><div id="1982" class="line none"> 1982  * objects are queues, semaphores, mutexes and event groups.  Task notifications</div><div id="1983" class="line none"> 1983  * are a method of sending an event directly to a task without the need for such</div><div id="1984" class="line none"> 1984  * an intermediary object.</div><div id="1985" class="line none"> 1985  *</div><div id="1986" class="line none"> 1986  * A notification sent to a task can optionally perform an action, such as</div><div id="1987" class="line none"> 1987  * update, overwrite or increment one of the task's notification values.  In</div><div id="1988" class="line none"> 1988  * that way task notifications can be used to send data to a task, or be used as</div><div id="1989" class="line none"> 1989  * light weight and fast binary or counting semaphores.</div><div id="1990" class="line none"> 1990  *</div><div id="1991" class="line none"> 1991  * A task can use xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() to</div><div id="1992" class="line none"> 1992  * [optionally] block to wait for a notification to be pending.  The task does</div><div id="1993" class="line none"> 1993  * not consume any CPU time while it is in the Blocked state.</div><div id="1994" class="line none"> 1994  *</div><div id="1995" class="line none"> 1995  * A notification sent to a task will remain pending until it is cleared by the</div><div id="1996" class="line none"> 1996  * task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their</div><div id="1997" class="line none"> 1997  * un-indexed equivalents).  If the task was already in the Blocked state to</div><div id="1998" class="line none"> 1998  * wait for a notification when the notification arrives then the task will</div><div id="1999" class="line none"> 1999  * automatically be removed from the Blocked state (unblocked) and the</div><div id="2000" class="line none"> 2000  * notification cleared.</div><div id="2001" class="line none"> 2001  *</div><div id="2002" class="line none"> 2002  * **NOTE** Each notification within the array operates independently - a task</div><div id="2003" class="line none"> 2003  * can only block on one notification within the array at a time and will not be</div><div id="2004" class="line none"> 2004  * unblocked by a notification sent to any other array index.</div><div id="2005" class="line none"> 2005  *</div><div id="2006" class="line none"> 2006  * Backward compatibility information:</div><div id="2007" class="line none"> 2007  * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and</div><div id="2008" class="line none"> 2008  * all task notification API functions operated on that value. Replacing the</div><div id="2009" class="line none"> 2009  * single notification value with an array of notification values necessitated a</div><div id="2010" class="line none"> 2010  * new set of API functions that could address specific notifications within the</div><div id="2011" class="line none"> 2011  * array.  xTaskNotify() is the original API function, and remains backward</div><div id="2012" class="line none"> 2012  * compatible by always operating on the notification value at index 0 in the</div><div id="2013" class="line none"> 2013  * array. Calling xTaskNotify() is equivalent to calling xTaskNotifyIndexed()</div><div id="2014" class="line none"> 2014  * with the uxIndexToNotify parameter set to 0.</div><div id="2015" class="line none"> 2015  *</div><div id="2016" class="line none"> 2016  * @param xTaskToNotify The handle of the task being notified.  The handle to a</div><div id="2017" class="line none"> 2017  * task can be returned from the xTaskCreate() API function used to create the</div><div id="2018" class="line none"> 2018  * task, and the handle of the currently running task can be obtained by calling</div><div id="2019" class="line none"> 2019  * xTaskGetCurrentTaskHandle().</div><div id="2020" class="line none"> 2020  *</div><div id="2021" class="line none"> 2021  * @param uxIndexToNotify The index within the target task's array of</div><div id="2022" class="line none"> 2022  * notification values to which the notification is to be sent.  uxIndexToNotify</div><div id="2023" class="line none"> 2023  * must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotify() does</div><div id="2024" class="line none"> 2024  * not have this parameter and always sends notifications to index 0.</div><div id="2025" class="line none"> 2025  *</div><div id="2026" class="line none"> 2026  * @param ulValue Data that can be sent with the notification.  How the data is</div><div id="2027" class="line none"> 2027  * used depends on the value of the eAction parameter.</div><div id="2028" class="line none"> 2028  *</div><div id="2029" class="line none"> 2029  * @param eAction Specifies how the notification updates the task's notification</div><div id="2030" class="line none"> 2030  * value, if at all.  Valid values for eAction are as follows:</div><div id="2031" class="line none"> 2031  *</div><div id="2032" class="line none"> 2032  * eSetBits -</div><div id="2033" class="line none"> 2033  * The target notification value is bitwise ORed with ulValue.</div><div id="2034" class="line none"> 2034  * xTaskNotifyIndexed() always returns pdPASS in this case.</div><div id="2035" class="line none"> 2035  *</div><div id="2036" class="line none"> 2036  * eIncrement -</div><div id="2037" class="line none"> 2037  * The target notification value is incremented.  ulValue is not used and</div><div id="2038" class="line none"> 2038  * xTaskNotifyIndexed() always returns pdPASS in this case.</div><div id="2039" class="line none"> 2039  *</div><div id="2040" class="line none"> 2040  * eSetValueWithOverwrite -</div><div id="2041" class="line none"> 2041  * The target notification value is set to the value of ulValue, even if the</div><div id="2042" class="line none"> 2042  * task being notified had not yet processed the previous notification at the</div><div id="2043" class="line none"> 2043  * same array index (the task already had a notification pending at that index).</div><div id="2044" class="line none"> 2044  * xTaskNotifyIndexed() always returns pdPASS in this case.</div><div id="2045" class="line none"> 2045  *</div><div id="2046" class="line none"> 2046  * eSetValueWithoutOverwrite -</div><div id="2047" class="line none"> 2047  * If the task being notified did not already have a notification pending at the</div><div id="2048" class="line none"> 2048  * same array index then the target notification value is set to ulValue and</div><div id="2049" class="line none"> 2049  * xTaskNotifyIndexed() will return pdPASS.  If the task being notified already</div><div id="2050" class="line none"> 2050  * had a notification pending at the same array index then no action is</div><div id="2051" class="line none"> 2051  * performed and pdFAIL is returned.</div><div id="2052" class="line none"> 2052  *</div><div id="2053" class="line none"> 2053  * eNoAction -</div><div id="2054" class="line none"> 2054  * The task receives a notification at the specified array index without the</div><div id="2055" class="line none"> 2055  * notification value at that index being updated.  ulValue is not used and</div><div id="2056" class="line none"> 2056  * xTaskNotifyIndexed() always returns pdPASS in this case.</div><div id="2057" class="line none"> 2057  *</div><div id="2058" class="line none"> 2058  * pulPreviousNotificationValue -</div><div id="2059" class="line none"> 2059  * Can be used to pass out the subject task's notification value before any</div><div id="2060" class="line none"> 2060  * bits are modified by the notify function.</div><div id="2061" class="line none"> 2061  *</div><div id="2062" class="line none"> 2062  * @return Dependent on the value of eAction.  See the description of the</div><div id="2063" class="line none"> 2063  * eAction parameter.</div><div id="2064" class="line none"> 2064  *</div><div id="2065" class="line none"> 2065  * \defgroup xTaskNotifyIndexed xTaskNotifyIndexed</div><div id="2066" class="line none"> 2066  * \ingroup TaskNotifications</div><div id="2067" class="line none"> 2067  */</div><div id="2068" class="line none"> 2068 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskGenericNotify( <a href="task.h.html#87">TaskHandle_t</a> xTaskToNotify,</div><div id="2069" class="line none"> 2069                                <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxIndexToNotify,</div><div id="2070" class="line none"> 2070                                uint32_t ulValue,</div><div id="2071" class="line none"> 2071                                <a href="task.h.html#114">eNotifyAction</a> eAction,</div><div id="2072" class="line none"> 2072                                uint32_t * pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;</div><div id="2073" class="line none"> 2073 #define <a href="task.h.html#2073">xTaskNotify</a>( xTaskToNotify, ulValue, eAction ) \</div><div id="2074" class="line none"> 2074     xTaskGenericNotify( ( xTaskToNotify ), ( <a href="task.h.html#74">tskDEFAULT_INDEX_TO_NOTIFY</a> ), ( ulValue ), ( eAction ), NULL )</div><div id="2075" class="line none"> 2075 #define <a href="task.h.html#2075">xTaskNotifyIndexed</a>( xTaskToNotify, uxIndexToNotify, ulValue, eAction ) \</div><div id="2076" class="line none"> 2076     xTaskGenericNotify( ( xTaskToNotify ), ( uxIndexToNotify ), ( ulValue ), ( eAction ), NULL )</div><div id="2077" class="line none"> 2077 </div><div id="2078" class="line none"> 2078 /**</div><div id="2079" class="line none"> 2079  * task. h</div><div id="2080" class="line none"> 2080  * @code{c}</div><div id="2081" class="line none"> 2081  * BaseType_t xTaskNotifyAndQueryIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue );</div><div id="2082" class="line none"> 2082  * BaseType_t xTaskNotifyAndQuery( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue );</div><div id="2083" class="line none"> 2083  * @endcode</div><div id="2084" class="line none"> 2084  *</div><div id="2085" class="line none"> 2085  * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.</div><div id="2086" class="line none"> 2086  *</div><div id="2087" class="line none"> 2087  * xTaskNotifyAndQueryIndexed() performs the same operation as</div><div id="2088" class="line none"> 2088  * xTaskNotifyIndexed() with the addition that it also returns the subject</div><div id="2089" class="line none"> 2089  * task's prior notification value (the notification value at the time the</div><div id="2090" class="line none"> 2090  * function is called rather than when the function returns) in the additional</div><div id="2091" class="line none"> 2091  * pulPreviousNotifyValue parameter.</div><div id="2092" class="line none"> 2092  *</div><div id="2093" class="line none"> 2093  * xTaskNotifyAndQuery() performs the same operation as xTaskNotify() with the</div><div id="2094" class="line none"> 2094  * addition that it also returns the subject task's prior notification value</div><div id="2095" class="line none"> 2095  * (the notification value as it was at the time the function is called, rather</div><div id="2096" class="line none"> 2096  * than when the function returns) in the additional pulPreviousNotifyValue</div><div id="2097" class="line none"> 2097  * parameter.</div><div id="2098" class="line none"> 2098  *</div><div id="2099" class="line none"> 2099  * \defgroup xTaskNotifyAndQueryIndexed xTaskNotifyAndQueryIndexed</div><div id="2100" class="line none"> 2100  * \ingroup TaskNotifications</div><div id="2101" class="line none"> 2101  */</div><div id="2102" class="line none"> 2102 #define <a href="task.h.html#2102">xTaskNotifyAndQuery</a>( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) \</div><div id="2103" class="line none"> 2103     xTaskGenericNotify( ( xTaskToNotify ), ( <a href="task.h.html#74">tskDEFAULT_INDEX_TO_NOTIFY</a> ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )</div><div id="2104" class="line none"> 2104 #define <a href="task.h.html#2104">xTaskNotifyAndQueryIndexed</a>( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotifyValue ) \</div><div id="2105" class="line none"> 2105     xTaskGenericNotify( ( xTaskToNotify ), ( uxIndexToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )</div><div id="2106" class="line none"> 2106 </div><div id="2107" class="line none"> 2107 /**</div><div id="2108" class="line none"> 2108  * task. h</div><div id="2109" class="line none"> 2109  * @code{c}</div><div id="2110" class="line none"> 2110  * BaseType_t xTaskNotifyIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</div><div id="2111" class="line none"> 2111  * BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</div><div id="2112" class="line none"> 2112  * @endcode</div><div id="2113" class="line none"> 2113  *</div><div id="2114" class="line none"> 2114  * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.</div><div id="2115" class="line none"> 2115  *</div><div id="2116" class="line none"> 2116  * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these</div><div id="2117" class="line none"> 2117  * functions to be available.</div><div id="2118" class="line none"> 2118  *</div><div id="2119" class="line none"> 2119  * A version of xTaskNotifyIndexed() that can be used from an interrupt service</div><div id="2120" class="line none"> 2120  * routine (ISR).</div><div id="2121" class="line none"> 2121  *</div><div id="2122" class="line none"> 2122  * Each task has a private array of "notification values" (or 'notifications'),</div><div id="2123" class="line none"> 2123  * each of which is a 32-bit unsigned integer (uint32_t).  The constant</div><div id="2124" class="line none"> 2124  * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the</div><div id="2125" class="line none"> 2125  * array, and (for backward compatibility) defaults to 1 if left undefined.</div><div id="2126" class="line none"> 2126  * Prior to FreeRTOS V10.4.0 there was only one notification value per task.</div><div id="2127" class="line none"> 2127  *</div><div id="2128" class="line none"> 2128  * Events can be sent to a task using an intermediary object.  Examples of such</div><div id="2129" class="line none"> 2129  * objects are queues, semaphores, mutexes and event groups.  Task notifications</div><div id="2130" class="line none"> 2130  * are a method of sending an event directly to a task without the need for such</div><div id="2131" class="line none"> 2131  * an intermediary object.</div><div id="2132" class="line none"> 2132  *</div><div id="2133" class="line none"> 2133  * A notification sent to a task can optionally perform an action, such as</div><div id="2134" class="line none"> 2134  * update, overwrite or increment one of the task's notification values.  In</div><div id="2135" class="line none"> 2135  * that way task notifications can be used to send data to a task, or be used as</div><div id="2136" class="line none"> 2136  * light weight and fast binary or counting semaphores.</div><div id="2137" class="line none"> 2137  *</div><div id="2138" class="line none"> 2138  * A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a</div><div id="2139" class="line none"> 2139  * notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block</div><div id="2140" class="line none"> 2140  * to wait for a notification value to have a non-zero value.  The task does</div><div id="2141" class="line none"> 2141  * not consume any CPU time while it is in the Blocked state.</div><div id="2142" class="line none"> 2142  *</div><div id="2143" class="line none"> 2143  * A notification sent to a task will remain pending until it is cleared by the</div><div id="2144" class="line none"> 2144  * task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their</div><div id="2145" class="line none"> 2145  * un-indexed equivalents).  If the task was already in the Blocked state to</div><div id="2146" class="line none"> 2146  * wait for a notification when the notification arrives then the task will</div><div id="2147" class="line none"> 2147  * automatically be removed from the Blocked state (unblocked) and the</div><div id="2148" class="line none"> 2148  * notification cleared.</div><div id="2149" class="line none"> 2149  *</div><div id="2150" class="line none"> 2150  * **NOTE** Each notification within the array operates independently - a task</div><div id="2151" class="line none"> 2151  * can only block on one notification within the array at a time and will not be</div><div id="2152" class="line none"> 2152  * unblocked by a notification sent to any other array index.</div><div id="2153" class="line none"> 2153  *</div><div id="2154" class="line none"> 2154  * Backward compatibility information:</div><div id="2155" class="line none"> 2155  * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and</div><div id="2156" class="line none"> 2156  * all task notification API functions operated on that value. Replacing the</div><div id="2157" class="line none"> 2157  * single notification value with an array of notification values necessitated a</div><div id="2158" class="line none"> 2158  * new set of API functions that could address specific notifications within the</div><div id="2159" class="line none"> 2159  * array.  xTaskNotifyFromISR() is the original API function, and remains</div><div id="2160" class="line none"> 2160  * backward compatible by always operating on the notification value at index 0</div><div id="2161" class="line none"> 2161  * within the array. Calling xTaskNotifyFromISR() is equivalent to calling</div><div id="2162" class="line none"> 2162  * xTaskNotifyIndexedFromISR() with the uxIndexToNotify parameter set to 0.</div><div id="2163" class="line none"> 2163  *</div><div id="2164" class="line none"> 2164  * @param uxIndexToNotify The index within the target task's array of</div><div id="2165" class="line none"> 2165  * notification values to which the notification is to be sent.  uxIndexToNotify</div><div id="2166" class="line none"> 2166  * must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyFromISR()</div><div id="2167" class="line none"> 2167  * does not have this parameter and always sends notifications to index 0.</div><div id="2168" class="line none"> 2168  *</div><div id="2169" class="line none"> 2169  * @param xTaskToNotify The handle of the task being notified.  The handle to a</div><div id="2170" class="line none"> 2170  * task can be returned from the xTaskCreate() API function used to create the</div><div id="2171" class="line none"> 2171  * task, and the handle of the currently running task can be obtained by calling</div><div id="2172" class="line none"> 2172  * xTaskGetCurrentTaskHandle().</div><div id="2173" class="line none"> 2173  *</div><div id="2174" class="line none"> 2174  * @param ulValue Data that can be sent with the notification.  How the data is</div><div id="2175" class="line none"> 2175  * used depends on the value of the eAction parameter.</div><div id="2176" class="line none"> 2176  *</div><div id="2177" class="line none"> 2177  * @param eAction Specifies how the notification updates the task's notification</div><div id="2178" class="line none"> 2178  * value, if at all.  Valid values for eAction are as follows:</div><div id="2179" class="line none"> 2179  *</div><div id="2180" class="line none"> 2180  * eSetBits -</div><div id="2181" class="line none"> 2181  * The task's notification value is bitwise ORed with ulValue.  xTaskNotify()</div><div id="2182" class="line none"> 2182  * always returns pdPASS in this case.</div><div id="2183" class="line none"> 2183  *</div><div id="2184" class="line none"> 2184  * eIncrement -</div><div id="2185" class="line none"> 2185  * The task's notification value is incremented.  ulValue is not used and</div><div id="2186" class="line none"> 2186  * xTaskNotify() always returns pdPASS in this case.</div><div id="2187" class="line none"> 2187  *</div><div id="2188" class="line none"> 2188  * eSetValueWithOverwrite -</div><div id="2189" class="line none"> 2189  * The task's notification value is set to the value of ulValue, even if the</div><div id="2190" class="line none"> 2190  * task being notified had not yet processed the previous notification (the</div><div id="2191" class="line none"> 2191  * task already had a notification pending).  xTaskNotify() always returns</div><div id="2192" class="line none"> 2192  * pdPASS in this case.</div><div id="2193" class="line none"> 2193  *</div><div id="2194" class="line none"> 2194  * eSetValueWithoutOverwrite -</div><div id="2195" class="line none"> 2195  * If the task being notified did not already have a notification pending then</div><div id="2196" class="line none"> 2196  * the task's notification value is set to ulValue and xTaskNotify() will</div><div id="2197" class="line none"> 2197  * return pdPASS.  If the task being notified already had a notification</div><div id="2198" class="line none"> 2198  * pending then no action is performed and pdFAIL is returned.</div><div id="2199" class="line none"> 2199  *</div><div id="2200" class="line none"> 2200  * eNoAction -</div><div id="2201" class="line none"> 2201  * The task receives a notification without its notification value being</div><div id="2202" class="line none"> 2202  * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in</div><div id="2203" class="line none"> 2203  * this case.</div><div id="2204" class="line none"> 2204  *</div><div id="2205" class="line none"> 2205  * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set</div><div id="2206" class="line none"> 2206  * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the</div><div id="2207" class="line none"> 2207  * task to which the notification was sent to leave the Blocked state, and the</div><div id="2208" class="line none"> 2208  * unblocked task has a priority higher than the currently running task.  If</div><div id="2209" class="line none"> 2209  * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should</div><div id="2210" class="line none"> 2210  * be requested before the interrupt is exited.  How a context switch is</div><div id="2211" class="line none"> 2211  * requested from an ISR is dependent on the port - see the documentation page</div><div id="2212" class="line none"> 2212  * for the port in use.</div><div id="2213" class="line none"> 2213  *</div><div id="2214" class="line none"> 2214  * @return Dependent on the value of eAction.  See the description of the</div><div id="2215" class="line none"> 2215  * eAction parameter.</div><div id="2216" class="line none"> 2216  *</div><div id="2217" class="line none"> 2217  * \defgroup xTaskNotifyIndexedFromISR xTaskNotifyIndexedFromISR</div><div id="2218" class="line none"> 2218  * \ingroup TaskNotifications</div><div id="2219" class="line none"> 2219  */</div><div id="2220" class="line none"> 2220 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskGenericNotifyFromISR( <a href="task.h.html#87">TaskHandle_t</a> xTaskToNotify,</div><div id="2221" class="line none"> 2221                                       <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxIndexToNotify,</div><div id="2222" class="line none"> 2222                                       uint32_t ulValue,</div><div id="2223" class="line none"> 2223                                       <a href="task.h.html#114">eNotifyAction</a> eAction,</div><div id="2224" class="line none"> 2224                                       uint32_t * pulPreviousNotificationValue,</div><div id="2225" class="line none"> 2225                                       <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> * pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;</div><div id="2226" class="line none"> 2226 #define <a href="task.h.html#2226">xTaskNotifyFromISR</a>( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) \</div><div id="2227" class="line none"> 2227     xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( <a href="task.h.html#74">tskDEFAULT_INDEX_TO_NOTIFY</a> ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )</div><div id="2228" class="line none"> 2228 #define <a href="task.h.html#2228">xTaskNotifyIndexedFromISR</a>( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) \</div><div id="2229" class="line none"> 2229     xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( uxIndexToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )</div><div id="2230" class="line none"> 2230 </div><div id="2231" class="line none"> 2231 /**</div><div id="2232" class="line none"> 2232  * task. h</div><div id="2233" class="line none"> 2233  * @code{c}</div><div id="2234" class="line none"> 2234  * BaseType_t xTaskNotifyAndQueryIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken );</div><div id="2235" class="line none"> 2235  * BaseType_t xTaskNotifyAndQueryFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken );</div><div id="2236" class="line none"> 2236  * @endcode</div><div id="2237" class="line none"> 2237  *</div><div id="2238" class="line none"> 2238  * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.</div><div id="2239" class="line none"> 2239  *</div><div id="2240" class="line none"> 2240  * xTaskNotifyAndQueryIndexedFromISR() performs the same operation as</div><div id="2241" class="line none"> 2241  * xTaskNotifyIndexedFromISR() with the addition that it also returns the</div><div id="2242" class="line none"> 2242  * subject task's prior notification value (the notification value at the time</div><div id="2243" class="line none"> 2243  * the function is called rather than at the time the function returns) in the</div><div id="2244" class="line none"> 2244  * additional pulPreviousNotifyValue parameter.</div><div id="2245" class="line none"> 2245  *</div><div id="2246" class="line none"> 2246  * xTaskNotifyAndQueryFromISR() performs the same operation as</div><div id="2247" class="line none"> 2247  * xTaskNotifyFromISR() with the addition that it also returns the subject</div><div id="2248" class="line none"> 2248  * task's prior notification value (the notification value at the time the</div><div id="2249" class="line none"> 2249  * function is called rather than at the time the function returns) in the</div><div id="2250" class="line none"> 2250  * additional pulPreviousNotifyValue parameter.</div><div id="2251" class="line none"> 2251  *</div><div id="2252" class="line none"> 2252  * \defgroup xTaskNotifyAndQueryIndexedFromISR xTaskNotifyAndQueryIndexedFromISR</div><div id="2253" class="line none"> 2253  * \ingroup TaskNotifications</div><div id="2254" class="line none"> 2254  */</div><div id="2255" class="line none"> 2255 #define <a href="task.h.html#2255">xTaskNotifyAndQueryIndexedFromISR</a>( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) \</div><div id="2256" class="line none"> 2256     xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( uxIndexToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )</div><div id="2257" class="line none"> 2257 #define <a href="task.h.html#2257">xTaskNotifyAndQueryFromISR</a>( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) \</div><div id="2258" class="line none"> 2258     xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( <a href="task.h.html#74">tskDEFAULT_INDEX_TO_NOTIFY</a> ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )</div><div id="2259" class="line none"> 2259 </div><div id="2260" class="line none"> 2260 /**</div><div id="2261" class="line none"> 2261  * task. h</div><div id="2262" class="line none"> 2262  * @code{c}</div><div id="2263" class="line none"> 2263  * BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</div><div id="2264" class="line none"> 2264  *</div><div id="2265" class="line none"> 2265  * BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</div><div id="2266" class="line none"> 2266  * @endcode</div><div id="2267" class="line none"> 2267  *</div><div id="2268" class="line none"> 2268  * Waits for a direct to task notification to be pending at a given index within</div><div id="2269" class="line none"> 2269  * an array of direct to task notifications.</div><div id="2270" class="line none"> 2270  *</div><div id="2271" class="line none"> 2271  * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.</div><div id="2272" class="line none"> 2272  *</div><div id="2273" class="line none"> 2273  * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this</div><div id="2274" class="line none"> 2274  * function to be available.</div><div id="2275" class="line none"> 2275  *</div><div id="2276" class="line none"> 2276  * Each task has a private array of "notification values" (or 'notifications'),</div><div id="2277" class="line none"> 2277  * each of which is a 32-bit unsigned integer (uint32_t).  The constant</div><div id="2278" class="line none"> 2278  * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the</div><div id="2279" class="line none"> 2279  * array, and (for backward compatibility) defaults to 1 if left undefined.</div><div id="2280" class="line none"> 2280  * Prior to FreeRTOS V10.4.0 there was only one notification value per task.</div><div id="2281" class="line none"> 2281  *</div><div id="2282" class="line none"> 2282  * Events can be sent to a task using an intermediary object.  Examples of such</div><div id="2283" class="line none"> 2283  * objects are queues, semaphores, mutexes and event groups.  Task notifications</div><div id="2284" class="line none"> 2284  * are a method of sending an event directly to a task without the need for such</div><div id="2285" class="line none"> 2285  * an intermediary object.</div><div id="2286" class="line none"> 2286  *</div><div id="2287" class="line none"> 2287  * A notification sent to a task can optionally perform an action, such as</div><div id="2288" class="line none"> 2288  * update, overwrite or increment one of the task's notification values.  In</div><div id="2289" class="line none"> 2289  * that way task notifications can be used to send data to a task, or be used as</div><div id="2290" class="line none"> 2290  * light weight and fast binary or counting semaphores.</div><div id="2291" class="line none"> 2291  *</div><div id="2292" class="line none"> 2292  * A notification sent to a task will remain pending until it is cleared by the</div><div id="2293" class="line none"> 2293  * task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their</div><div id="2294" class="line none"> 2294  * un-indexed equivalents).  If the task was already in the Blocked state to</div><div id="2295" class="line none"> 2295  * wait for a notification when the notification arrives then the task will</div><div id="2296" class="line none"> 2296  * automatically be removed from the Blocked state (unblocked) and the</div><div id="2297" class="line none"> 2297  * notification cleared.</div><div id="2298" class="line none"> 2298  *</div><div id="2299" class="line none"> 2299  * A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a</div><div id="2300" class="line none"> 2300  * notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block</div><div id="2301" class="line none"> 2301  * to wait for a notification value to have a non-zero value.  The task does</div><div id="2302" class="line none"> 2302  * not consume any CPU time while it is in the Blocked state.</div><div id="2303" class="line none"> 2303  *</div><div id="2304" class="line none"> 2304  * **NOTE** Each notification within the array operates independently - a task</div><div id="2305" class="line none"> 2305  * can only block on one notification within the array at a time and will not be</div><div id="2306" class="line none"> 2306  * unblocked by a notification sent to any other array index.</div><div id="2307" class="line none"> 2307  *</div><div id="2308" class="line none"> 2308  * Backward compatibility information:</div><div id="2309" class="line none"> 2309  * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and</div><div id="2310" class="line none"> 2310  * all task notification API functions operated on that value. Replacing the</div><div id="2311" class="line none"> 2311  * single notification value with an array of notification values necessitated a</div><div id="2312" class="line none"> 2312  * new set of API functions that could address specific notifications within the</div><div id="2313" class="line none"> 2313  * array.  xTaskNotifyWait() is the original API function, and remains backward</div><div id="2314" class="line none"> 2314  * compatible by always operating on the notification value at index 0 in the</div><div id="2315" class="line none"> 2315  * array. Calling xTaskNotifyWait() is equivalent to calling</div><div id="2316" class="line none"> 2316  * xTaskNotifyWaitIndexed() with the uxIndexToWaitOn parameter set to 0.</div><div id="2317" class="line none"> 2317  *</div><div id="2318" class="line none"> 2318  * @param uxIndexToWaitOn The index within the calling task's array of</div><div id="2319" class="line none"> 2319  * notification values on which the calling task will wait for a notification to</div><div id="2320" class="line none"> 2320  * be received.  uxIndexToWaitOn must be less than</div><div id="2321" class="line none"> 2321  * configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyWait() does</div><div id="2322" class="line none"> 2322  * not have this parameter and always waits for notifications on index 0.</div><div id="2323" class="line none"> 2323  *</div><div id="2324" class="line none"> 2324  * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value</div><div id="2325" class="line none"> 2325  * will be cleared in the calling task's notification value before the task</div><div id="2326" class="line none"> 2326  * checks to see if any notifications are pending, and optionally blocks if no</div><div id="2327" class="line none"> 2327  * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if</div><div id="2328" class="line none"> 2328  * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have</div><div id="2329" class="line none"> 2329  * the effect of resetting the task's notification value to 0.  Setting</div><div id="2330" class="line none"> 2330  * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.</div><div id="2331" class="line none"> 2331  *</div><div id="2332" class="line none"> 2332  * @param ulBitsToClearOnExit If a notification is pending or received before</div><div id="2333" class="line none"> 2333  * the calling task exits the xTaskNotifyWait() function then the task's</div><div id="2334" class="line none"> 2334  * notification value (see the xTaskNotify() API function) is passed out using</div><div id="2335" class="line none"> 2335  * the pulNotificationValue parameter.  Then any bits that are set in</div><div id="2336" class="line none"> 2336  * ulBitsToClearOnExit will be cleared in the task's notification value (note</div><div id="2337" class="line none"> 2337  * *pulNotificationValue is set before any bits are cleared).  Setting</div><div id="2338" class="line none"> 2338  * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL</div><div id="2339" class="line none"> 2339  * (if limits.h is not included) will have the effect of resetting the task's</div><div id="2340" class="line none"> 2340  * notification value to 0 before the function exits.  Setting</div><div id="2341" class="line none"> 2341  * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged</div><div id="2342" class="line none"> 2342  * when the function exits (in which case the value passed out in</div><div id="2343" class="line none"> 2343  * pulNotificationValue will match the task's notification value).</div><div id="2344" class="line none"> 2344  *</div><div id="2345" class="line none"> 2345  * @param pulNotificationValue Used to pass the task's notification value out</div><div id="2346" class="line none"> 2346  * of the function.  Note the value passed out will not be effected by the</div><div id="2347" class="line none"> 2347  * clearing of any bits caused by ulBitsToClearOnExit being non-zero.</div><div id="2348" class="line none"> 2348  *</div><div id="2349" class="line none"> 2349  * @param xTicksToWait The maximum amount of time that the task should wait in</div><div id="2350" class="line none"> 2350  * the Blocked state for a notification to be received, should a notification</div><div id="2351" class="line none"> 2351  * not already be pending when xTaskNotifyWait() was called.  The task</div><div id="2352" class="line none"> 2352  * will not consume any processing time while it is in the Blocked state.  This</div><div id="2353" class="line none"> 2353  * is specified in kernel ticks, the macro pdMS_TO_TICKS( value_in_ms ) can be</div><div id="2354" class="line none"> 2354  * used to convert a time specified in milliseconds to a time specified in</div><div id="2355" class="line none"> 2355  * ticks.</div><div id="2356" class="line none"> 2356  *</div><div id="2357" class="line none"> 2357  * @return If a notification was received (including notifications that were</div><div id="2358" class="line none"> 2358  * already pending when xTaskNotifyWait was called) then pdPASS is</div><div id="2359" class="line none"> 2359  * returned.  Otherwise pdFAIL is returned.</div><div id="2360" class="line none"> 2360  *</div><div id="2361" class="line none"> 2361  * \defgroup xTaskNotifyWaitIndexed xTaskNotifyWaitIndexed</div><div id="2362" class="line none"> 2362  * \ingroup TaskNotifications</div><div id="2363" class="line none"> 2363  */</div><div id="2364" class="line none"> 2364 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskGenericNotifyWait( <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxIndexToWaitOn,</div><div id="2365" class="line none"> 2365                                    uint32_t ulBitsToClearOnEntry,</div><div id="2366" class="line none"> 2366                                    uint32_t ulBitsToClearOnExit,</div><div id="2367" class="line none"> 2367                                    uint32_t * pulNotificationValue,</div><div id="2368" class="line none"> 2368                                    <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> xTicksToWait ) PRIVILEGED_FUNCTION;</div><div id="2369" class="line none"> 2369 #define <a href="task.h.html#2369">xTaskNotifyWait</a>( ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait ) \</div><div id="2370" class="line none"> 2370     xTaskGenericNotifyWait( <a href="task.h.html#74">tskDEFAULT_INDEX_TO_NOTIFY</a>, ( ulBitsToClearOnEntry ), ( ulBitsToClearOnExit ), ( pulNotificationValue ), ( xTicksToWait ) )</div><div id="2371" class="line none"> 2371 #define <a href="task.h.html#2371">xTaskNotifyWaitIndexed</a>( uxIndexToWaitOn, ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait ) \</div><div id="2372" class="line none"> 2372     xTaskGenericNotifyWait( ( uxIndexToWaitOn ), ( ulBitsToClearOnEntry ), ( ulBitsToClearOnExit ), ( pulNotificationValue ), ( xTicksToWait ) )</div><div id="2373" class="line none"> 2373 </div><div id="2374" class="line none"> 2374 /**</div><div id="2375" class="line none"> 2375  * task. h</div><div id="2376" class="line none"> 2376  * @code{c}</div><div id="2377" class="line none"> 2377  * BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify );</div><div id="2378" class="line none"> 2378  * BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );</div><div id="2379" class="line none"> 2379  * @endcode</div><div id="2380" class="line none"> 2380  *</div><div id="2381" class="line none"> 2381  * Sends a direct to task notification to a particular index in the target</div><div id="2382" class="line none"> 2382  * task's notification array in a manner similar to giving a counting semaphore.</div><div id="2383" class="line none"> 2383  *</div><div id="2384" class="line none"> 2384  * See https://www.FreeRTOS.org/RTOS-task-notifications.html for more details.</div><div id="2385" class="line none"> 2385  *</div><div id="2386" class="line none"> 2386  * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these</div><div id="2387" class="line none"> 2387  * macros to be available.</div><div id="2388" class="line none"> 2388  *</div><div id="2389" class="line none"> 2389  * Each task has a private array of "notification values" (or 'notifications'),</div><div id="2390" class="line none"> 2390  * each of which is a 32-bit unsigned integer (uint32_t).  The constant</div><div id="2391" class="line none"> 2391  * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the</div><div id="2392" class="line none"> 2392  * array, and (for backward compatibility) defaults to 1 if left undefined.</div><div id="2393" class="line none"> 2393  * Prior to FreeRTOS V10.4.0 there was only one notification value per task.</div><div id="2394" class="line none"> 2394  *</div><div id="2395" class="line none"> 2395  * Events can be sent to a task using an intermediary object.  Examples of such</div><div id="2396" class="line none"> 2396  * objects are queues, semaphores, mutexes and event groups.  Task notifications</div><div id="2397" class="line none"> 2397  * are a method of sending an event directly to a task without the need for such</div><div id="2398" class="line none"> 2398  * an intermediary object.</div><div id="2399" class="line none"> 2399  *</div><div id="2400" class="line none"> 2400  * A notification sent to a task can optionally perform an action, such as</div><div id="2401" class="line none"> 2401  * update, overwrite or increment one of the task's notification values.  In</div><div id="2402" class="line none"> 2402  * that way task notifications can be used to send data to a task, or be used as</div><div id="2403" class="line none"> 2403  * light weight and fast binary or counting semaphores.</div><div id="2404" class="line none"> 2404  *</div><div id="2405" class="line none"> 2405  * xTaskNotifyGiveIndexed() is a helper macro intended for use when task</div><div id="2406" class="line none"> 2406  * notifications are used as light weight and faster binary or counting</div><div id="2407" class="line none"> 2407  * semaphore equivalents.  Actual FreeRTOS semaphores are given using the</div><div id="2408" class="line none"> 2408  * xSemaphoreGive() API function, the equivalent action that instead uses a task</div><div id="2409" class="line none"> 2409  * notification is xTaskNotifyGiveIndexed().</div><div id="2410" class="line none"> 2410  *</div><div id="2411" class="line none"> 2411  * When task notifications are being used as a binary or counting semaphore</div><div id="2412" class="line none"> 2412  * equivalent then the task being notified should wait for the notification</div><div id="2413" class="line none"> 2413  * using the ulTaskNotifyTakeIndexed() API function rather than the</div><div id="2414" class="line none"> 2414  * xTaskNotifyWaitIndexed() API function.</div><div id="2415" class="line none"> 2415  *</div><div id="2416" class="line none"> 2416  * **NOTE** Each notification within the array operates independently - a task</div><div id="2417" class="line none"> 2417  * can only block on one notification within the array at a time and will not be</div><div id="2418" class="line none"> 2418  * unblocked by a notification sent to any other array index.</div><div id="2419" class="line none"> 2419  *</div><div id="2420" class="line none"> 2420  * Backward compatibility information:</div><div id="2421" class="line none"> 2421  * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and</div><div id="2422" class="line none"> 2422  * all task notification API functions operated on that value. Replacing the</div><div id="2423" class="line none"> 2423  * single notification value with an array of notification values necessitated a</div><div id="2424" class="line none"> 2424  * new set of API functions that could address specific notifications within the</div><div id="2425" class="line none"> 2425  * array.  xTaskNotifyGive() is the original API function, and remains backward</div><div id="2426" class="line none"> 2426  * compatible by always operating on the notification value at index 0 in the</div><div id="2427" class="line none"> 2427  * array. Calling xTaskNotifyGive() is equivalent to calling</div><div id="2428" class="line none"> 2428  * xTaskNotifyGiveIndexed() with the uxIndexToNotify parameter set to 0.</div><div id="2429" class="line none"> 2429  *</div><div id="2430" class="line none"> 2430  * @param xTaskToNotify The handle of the task being notified.  The handle to a</div><div id="2431" class="line none"> 2431  * task can be returned from the xTaskCreate() API function used to create the</div><div id="2432" class="line none"> 2432  * task, and the handle of the currently running task can be obtained by calling</div><div id="2433" class="line none"> 2433  * xTaskGetCurrentTaskHandle().</div><div id="2434" class="line none"> 2434  *</div><div id="2435" class="line none"> 2435  * @param uxIndexToNotify The index within the target task's array of</div><div id="2436" class="line none"> 2436  * notification values to which the notification is to be sent.  uxIndexToNotify</div><div id="2437" class="line none"> 2437  * must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyGive()</div><div id="2438" class="line none"> 2438  * does not have this parameter and always sends notifications to index 0.</div><div id="2439" class="line none"> 2439  *</div><div id="2440" class="line none"> 2440  * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the</div><div id="2441" class="line none"> 2441  * eAction parameter set to eIncrement - so pdPASS is always returned.</div><div id="2442" class="line none"> 2442  *</div><div id="2443" class="line none"> 2443  * \defgroup xTaskNotifyGiveIndexed xTaskNotifyGiveIndexed</div><div id="2444" class="line none"> 2444  * \ingroup TaskNotifications</div><div id="2445" class="line none"> 2445  */</div><div id="2446" class="line none"> 2446 #define <a href="task.h.html#2446">xTaskNotifyGive</a>( xTaskToNotify ) \</div><div id="2447" class="line none"> 2447     xTaskGenericNotify( ( xTaskToNotify ), ( <a href="task.h.html#74">tskDEFAULT_INDEX_TO_NOTIFY</a> ), ( 0 ), <a href="task.h.html#111">eIncrement</a>, NULL )</div><div id="2448" class="line none"> 2448 #define <a href="task.h.html#2448">xTaskNotifyGiveIndexed</a>( xTaskToNotify, uxIndexToNotify ) \</div><div id="2449" class="line none"> 2449     xTaskGenericNotify( ( xTaskToNotify ), ( uxIndexToNotify ), ( 0 ), <a href="task.h.html#111">eIncrement</a>, NULL )</div><div id="2450" class="line none"> 2450 </div><div id="2451" class="line none"> 2451 /**</div><div id="2452" class="line none"> 2452  * task. h</div><div id="2453" class="line none"> 2453  * @code{c}</div><div id="2454" class="line none"> 2454  * void vTaskNotifyGiveIndexedFromISR( TaskHandle_t xTaskHandle, UBaseType_t uxIndexToNotify, BaseType_t *pxHigherPriorityTaskWoken );</div><div id="2455" class="line none"> 2455  * void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );</div><div id="2456" class="line none"> 2456  * @endcode</div><div id="2457" class="line none"> 2457  *</div><div id="2458" class="line none"> 2458  * A version of xTaskNotifyGiveIndexed() that can be called from an interrupt</div><div id="2459" class="line none"> 2459  * service routine (ISR).</div><div id="2460" class="line none"> 2460  *</div><div id="2461" class="line none"> 2461  * See https://www.FreeRTOS.org/RTOS-task-notifications.html for more details.</div><div id="2462" class="line none"> 2462  *</div><div id="2463" class="line none"> 2463  * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro</div><div id="2464" class="line none"> 2464  * to be available.</div><div id="2465" class="line none"> 2465  *</div><div id="2466" class="line none"> 2466  * Each task has a private array of "notification values" (or 'notifications'),</div><div id="2467" class="line none"> 2467  * each of which is a 32-bit unsigned integer (uint32_t).  The constant</div><div id="2468" class="line none"> 2468  * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the</div><div id="2469" class="line none"> 2469  * array, and (for backward compatibility) defaults to 1 if left undefined.</div><div id="2470" class="line none"> 2470  * Prior to FreeRTOS V10.4.0 there was only one notification value per task.</div><div id="2471" class="line none"> 2471  *</div><div id="2472" class="line none"> 2472  * Events can be sent to a task using an intermediary object.  Examples of such</div><div id="2473" class="line none"> 2473  * objects are queues, semaphores, mutexes and event groups.  Task notifications</div><div id="2474" class="line none"> 2474  * are a method of sending an event directly to a task without the need for such</div><div id="2475" class="line none"> 2475  * an intermediary object.</div><div id="2476" class="line none"> 2476  *</div><div id="2477" class="line none"> 2477  * A notification sent to a task can optionally perform an action, such as</div><div id="2478" class="line none"> 2478  * update, overwrite or increment one of the task's notification values.  In</div><div id="2479" class="line none"> 2479  * that way task notifications can be used to send data to a task, or be used as</div><div id="2480" class="line none"> 2480  * light weight and fast binary or counting semaphores.</div><div id="2481" class="line none"> 2481  *</div><div id="2482" class="line none"> 2482  * vTaskNotifyGiveIndexedFromISR() is intended for use when task notifications</div><div id="2483" class="line none"> 2483  * are used as light weight and faster binary or counting semaphore equivalents.</div><div id="2484" class="line none"> 2484  * Actual FreeRTOS semaphores are given from an ISR using the</div><div id="2485" class="line none"> 2485  * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses</div><div id="2486" class="line none"> 2486  * a task notification is vTaskNotifyGiveIndexedFromISR().</div><div id="2487" class="line none"> 2487  *</div><div id="2488" class="line none"> 2488  * When task notifications are being used as a binary or counting semaphore</div><div id="2489" class="line none"> 2489  * equivalent then the task being notified should wait for the notification</div><div id="2490" class="line none"> 2490  * using the ulTaskNotifyTakeIndexed() API function rather than the</div><div id="2491" class="line none"> 2491  * xTaskNotifyWaitIndexed() API function.</div><div id="2492" class="line none"> 2492  *</div><div id="2493" class="line none"> 2493  * **NOTE** Each notification within the array operates independently - a task</div><div id="2494" class="line none"> 2494  * can only block on one notification within the array at a time and will not be</div><div id="2495" class="line none"> 2495  * unblocked by a notification sent to any other array index.</div><div id="2496" class="line none"> 2496  *</div><div id="2497" class="line none"> 2497  * Backward compatibility information:</div><div id="2498" class="line none"> 2498  * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and</div><div id="2499" class="line none"> 2499  * all task notification API functions operated on that value. Replacing the</div><div id="2500" class="line none"> 2500  * single notification value with an array of notification values necessitated a</div><div id="2501" class="line none"> 2501  * new set of API functions that could address specific notifications within the</div><div id="2502" class="line none"> 2502  * array.  xTaskNotifyFromISR() is the original API function, and remains</div><div id="2503" class="line none"> 2503  * backward compatible by always operating on the notification value at index 0</div><div id="2504" class="line none"> 2504  * within the array. Calling xTaskNotifyGiveFromISR() is equivalent to calling</div><div id="2505" class="line none"> 2505  * xTaskNotifyGiveIndexedFromISR() with the uxIndexToNotify parameter set to 0.</div><div id="2506" class="line none"> 2506  *</div><div id="2507" class="line none"> 2507  * @param xTaskToNotify The handle of the task being notified.  The handle to a</div><div id="2508" class="line none"> 2508  * task can be returned from the xTaskCreate() API function used to create the</div><div id="2509" class="line none"> 2509  * task, and the handle of the currently running task can be obtained by calling</div><div id="2510" class="line none"> 2510  * xTaskGetCurrentTaskHandle().</div><div id="2511" class="line none"> 2511  *</div><div id="2512" class="line none"> 2512  * @param uxIndexToNotify The index within the target task's array of</div><div id="2513" class="line none"> 2513  * notification values to which the notification is to be sent.  uxIndexToNotify</div><div id="2514" class="line none"> 2514  * must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.</div><div id="2515" class="line none"> 2515  * xTaskNotifyGiveFromISR() does not have this parameter and always sends</div><div id="2516" class="line none"> 2516  * notifications to index 0.</div><div id="2517" class="line none"> 2517  *</div><div id="2518" class="line none"> 2518  * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set</div><div id="2519" class="line none"> 2519  * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the</div><div id="2520" class="line none"> 2520  * task to which the notification was sent to leave the Blocked state, and the</div><div id="2521" class="line none"> 2521  * unblocked task has a priority higher than the currently running task.  If</div><div id="2522" class="line none"> 2522  * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch</div><div id="2523" class="line none"> 2523  * should be requested before the interrupt is exited.  How a context switch is</div><div id="2524" class="line none"> 2524  * requested from an ISR is dependent on the port - see the documentation page</div><div id="2525" class="line none"> 2525  * for the port in use.</div><div id="2526" class="line none"> 2526  *</div><div id="2527" class="line none"> 2527  * \defgroup vTaskNotifyGiveIndexedFromISR vTaskNotifyGiveIndexedFromISR</div><div id="2528" class="line none"> 2528  * \ingroup TaskNotifications</div><div id="2529" class="line none"> 2529  */</div><div id="2530" class="line none"> 2530 void vTaskGenericNotifyGiveFromISR( <a href="task.h.html#87">TaskHandle_t</a> xTaskToNotify,</div><div id="2531" class="line none"> 2531                                     <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxIndexToNotify,</div><div id="2532" class="line none"> 2532                                     <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> * pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;</div><div id="2533" class="line none"> 2533 #define <a href="task.h.html#2533">vTaskNotifyGiveFromISR</a>( xTaskToNotify, pxHigherPriorityTaskWoken ) \</div><div id="2534" class="line none"> 2534     vTaskGenericNotifyGiveFromISR( ( xTaskToNotify ), ( <a href="task.h.html#74">tskDEFAULT_INDEX_TO_NOTIFY</a> ), ( pxHigherPriorityTaskWoken ) );</div><div id="2535" class="line none"> 2535 #define <a href="task.h.html#2535">vTaskNotifyGiveIndexedFromISR</a>( xTaskToNotify, uxIndexToNotify, pxHigherPriorityTaskWoken ) \</div><div id="2536" class="line none"> 2536     vTaskGenericNotifyGiveFromISR( ( xTaskToNotify ), ( uxIndexToNotify ), ( pxHigherPriorityTaskWoken ) );</div><div id="2537" class="line none"> 2537 </div><div id="2538" class="line none"> 2538 /**</div><div id="2539" class="line none"> 2539  * task. h</div><div id="2540" class="line none"> 2540  * @code{c}</div><div id="2541" class="line none"> 2541  * uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn, BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</div><div id="2542" class="line none"> 2542  *</div><div id="2543" class="line none"> 2543  * uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</div><div id="2544" class="line none"> 2544  * @endcode</div><div id="2545" class="line none"> 2545  *</div><div id="2546" class="line none"> 2546  * Waits for a direct to task notification on a particular index in the calling</div><div id="2547" class="line none"> 2547  * task's notification array in a manner similar to taking a counting semaphore.</div><div id="2548" class="line none"> 2548  *</div><div id="2549" class="line none"> 2549  * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.</div><div id="2550" class="line none"> 2550  *</div><div id="2551" class="line none"> 2551  * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this</div><div id="2552" class="line none"> 2552  * function to be available.</div><div id="2553" class="line none"> 2553  *</div><div id="2554" class="line none"> 2554  * Each task has a private array of "notification values" (or 'notifications'),</div><div id="2555" class="line none"> 2555  * each of which is a 32-bit unsigned integer (uint32_t).  The constant</div><div id="2556" class="line none"> 2556  * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the</div><div id="2557" class="line none"> 2557  * array, and (for backward compatibility) defaults to 1 if left undefined.</div><div id="2558" class="line none"> 2558  * Prior to FreeRTOS V10.4.0 there was only one notification value per task.</div><div id="2559" class="line none"> 2559  *</div><div id="2560" class="line none"> 2560  * Events can be sent to a task using an intermediary object.  Examples of such</div><div id="2561" class="line none"> 2561  * objects are queues, semaphores, mutexes and event groups.  Task notifications</div><div id="2562" class="line none"> 2562  * are a method of sending an event directly to a task without the need for such</div><div id="2563" class="line none"> 2563  * an intermediary object.</div><div id="2564" class="line none"> 2564  *</div><div id="2565" class="line none"> 2565  * A notification sent to a task can optionally perform an action, such as</div><div id="2566" class="line none"> 2566  * update, overwrite or increment one of the task's notification values.  In</div><div id="2567" class="line none"> 2567  * that way task notifications can be used to send data to a task, or be used as</div><div id="2568" class="line none"> 2568  * light weight and fast binary or counting semaphores.</div><div id="2569" class="line none"> 2569  *</div><div id="2570" class="line none"> 2570  * ulTaskNotifyTakeIndexed() is intended for use when a task notification is</div><div id="2571" class="line none"> 2571  * used as a faster and lighter weight binary or counting semaphore alternative.</div><div id="2572" class="line none"> 2572  * Actual FreeRTOS semaphores are taken using the xSemaphoreTake() API function,</div><div id="2573" class="line none"> 2573  * the equivalent action that instead uses a task notification is</div><div id="2574" class="line none"> 2574  * ulTaskNotifyTakeIndexed().</div><div id="2575" class="line none"> 2575  *</div><div id="2576" class="line none"> 2576  * When a task is using its notification value as a binary or counting semaphore</div><div id="2577" class="line none"> 2577  * other tasks should send notifications to it using the xTaskNotifyGiveIndexed()</div><div id="2578" class="line none"> 2578  * macro, or xTaskNotifyIndex() function with the eAction parameter set to</div><div id="2579" class="line none"> 2579  * eIncrement.</div><div id="2580" class="line none"> 2580  *</div><div id="2581" class="line none"> 2581  * ulTaskNotifyTakeIndexed() can either clear the task's notification value at</div><div id="2582" class="line none"> 2582  * the array index specified by the uxIndexToWaitOn parameter to zero on exit,</div><div id="2583" class="line none"> 2583  * in which case the notification value acts like a binary semaphore, or</div><div id="2584" class="line none"> 2584  * decrement the notification value on exit, in which case the notification</div><div id="2585" class="line none"> 2585  * value acts like a counting semaphore.</div><div id="2586" class="line none"> 2586  *</div><div id="2587" class="line none"> 2587  * A task can use ulTaskNotifyTakeIndexed() to [optionally] block to wait for</div><div id="2588" class="line none"> 2588  * a notification.  The task does not consume any CPU time while it is in the</div><div id="2589" class="line none"> 2589  * Blocked state.</div><div id="2590" class="line none"> 2590  *</div><div id="2591" class="line none"> 2591  * Where as xTaskNotifyWaitIndexed() will return when a notification is pending,</div><div id="2592" class="line none"> 2592  * ulTaskNotifyTakeIndexed() will return when the task's notification value is</div><div id="2593" class="line none"> 2593  * not zero.</div><div id="2594" class="line none"> 2594  *</div><div id="2595" class="line none"> 2595  * **NOTE** Each notification within the array operates independently - a task</div><div id="2596" class="line none"> 2596  * can only block on one notification within the array at a time and will not be</div><div id="2597" class="line none"> 2597  * unblocked by a notification sent to any other array index.</div><div id="2598" class="line none"> 2598  *</div><div id="2599" class="line none"> 2599  * Backward compatibility information:</div><div id="2600" class="line none"> 2600  * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and</div><div id="2601" class="line none"> 2601  * all task notification API functions operated on that value. Replacing the</div><div id="2602" class="line none"> 2602  * single notification value with an array of notification values necessitated a</div><div id="2603" class="line none"> 2603  * new set of API functions that could address specific notifications within the</div><div id="2604" class="line none"> 2604  * array.  ulTaskNotifyTake() is the original API function, and remains backward</div><div id="2605" class="line none"> 2605  * compatible by always operating on the notification value at index 0 in the</div><div id="2606" class="line none"> 2606  * array. Calling ulTaskNotifyTake() is equivalent to calling</div><div id="2607" class="line none"> 2607  * ulTaskNotifyTakeIndexed() with the uxIndexToWaitOn parameter set to 0.</div><div id="2608" class="line none"> 2608  *</div><div id="2609" class="line none"> 2609  * @param uxIndexToWaitOn The index within the calling task's array of</div><div id="2610" class="line none"> 2610  * notification values on which the calling task will wait for a notification to</div><div id="2611" class="line none"> 2611  * be non-zero.  uxIndexToWaitOn must be less than</div><div id="2612" class="line none"> 2612  * configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyTake() does</div><div id="2613" class="line none"> 2613  * not have this parameter and always waits for notifications on index 0.</div><div id="2614" class="line none"> 2614  *</div><div id="2615" class="line none"> 2615  * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's</div><div id="2616" class="line none"> 2616  * notification value is decremented when the function exits.  In this way the</div><div id="2617" class="line none"> 2617  * notification value acts like a counting semaphore.  If xClearCountOnExit is</div><div id="2618" class="line none"> 2618  * not pdFALSE then the task's notification value is cleared to zero when the</div><div id="2619" class="line none"> 2619  * function exits.  In this way the notification value acts like a binary</div><div id="2620" class="line none"> 2620  * semaphore.</div><div id="2621" class="line none"> 2621  *</div><div id="2622" class="line none"> 2622  * @param xTicksToWait The maximum amount of time that the task should wait in</div><div id="2623" class="line none"> 2623  * the Blocked state for the task's notification value to be greater than zero,</div><div id="2624" class="line none"> 2624  * should the count not already be greater than zero when</div><div id="2625" class="line none"> 2625  * ulTaskNotifyTake() was called.  The task will not consume any processing</div><div id="2626" class="line none"> 2626  * time while it is in the Blocked state.  This is specified in kernel ticks,</div><div id="2627" class="line none"> 2627  * the macro pdMS_TO_TICKS( value_in_ms ) can be used to convert a time</div><div id="2628" class="line none"> 2628  * specified in milliseconds to a time specified in ticks.</div><div id="2629" class="line none"> 2629  *</div><div id="2630" class="line none"> 2630  * @return The task's notification count before it is either cleared to zero or</div><div id="2631" class="line none"> 2631  * decremented (see the xClearCountOnExit parameter).</div><div id="2632" class="line none"> 2632  *</div><div id="2633" class="line none"> 2633  * \defgroup ulTaskNotifyTakeIndexed ulTaskNotifyTakeIndexed</div><div id="2634" class="line none"> 2634  * \ingroup TaskNotifications</div><div id="2635" class="line none"> 2635  */</div><div id="2636" class="line none"> 2636 uint32_t ulTaskGenericNotifyTake( <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxIndexToWaitOn,</div><div id="2637" class="line none"> 2637                                   <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xClearCountOnExit,</div><div id="2638" class="line none"> 2638                                   <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> xTicksToWait ) PRIVILEGED_FUNCTION;</div><div id="2639" class="line none"> 2639 #define <a href="task.h.html#2639">ulTaskNotifyTake</a>( xClearCountOnExit, xTicksToWait ) \</div><div id="2640" class="line none"> 2640     ulTaskGenericNotifyTake( ( <a href="task.h.html#74">tskDEFAULT_INDEX_TO_NOTIFY</a> ), ( xClearCountOnExit ), ( xTicksToWait ) )</div><div id="2641" class="line none"> 2641 #define <a href="task.h.html#2641">ulTaskNotifyTakeIndexed</a>( uxIndexToWaitOn, xClearCountOnExit, xTicksToWait ) \</div><div id="2642" class="line none"> 2642     ulTaskGenericNotifyTake( ( uxIndexToWaitOn ), ( xClearCountOnExit ), ( xTicksToWait ) )</div><div id="2643" class="line none"> 2643 </div><div id="2644" class="line none"> 2644 /**</div><div id="2645" class="line none"> 2645  * task. h</div><div id="2646" class="line none"> 2646  * @code{c}</div><div id="2647" class="line none"> 2647  * BaseType_t xTaskNotifyStateClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToCLear );</div><div id="2648" class="line none"> 2648  *</div><div id="2649" class="line none"> 2649  * BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );</div><div id="2650" class="line none"> 2650  * @endcode</div><div id="2651" class="line none"> 2651  *</div><div id="2652" class="line none"> 2652  * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.</div><div id="2653" class="line none"> 2653  *</div><div id="2654" class="line none"> 2654  * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these</div><div id="2655" class="line none"> 2655  * functions to be available.</div><div id="2656" class="line none"> 2656  *</div><div id="2657" class="line none"> 2657  * Each task has a private array of "notification values" (or 'notifications'),</div><div id="2658" class="line none"> 2658  * each of which is a 32-bit unsigned integer (uint32_t).  The constant</div><div id="2659" class="line none"> 2659  * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the</div><div id="2660" class="line none"> 2660  * array, and (for backward compatibility) defaults to 1 if left undefined.</div><div id="2661" class="line none"> 2661  * Prior to FreeRTOS V10.4.0 there was only one notification value per task.</div><div id="2662" class="line none"> 2662  *</div><div id="2663" class="line none"> 2663  * If a notification is sent to an index within the array of notifications then</div><div id="2664" class="line none"> 2664  * the notification at that index is said to be 'pending' until it is read or</div><div id="2665" class="line none"> 2665  * explicitly cleared by the receiving task.  xTaskNotifyStateClearIndexed()</div><div id="2666" class="line none"> 2666  * is the function that clears a pending notification without reading the</div><div id="2667" class="line none"> 2667  * notification value.  The notification value at the same array index is not</div><div id="2668" class="line none"> 2668  * altered.  Set xTask to NULL to clear the notification state of the calling</div><div id="2669" class="line none"> 2669  * task.</div><div id="2670" class="line none"> 2670  *</div><div id="2671" class="line none"> 2671  * Backward compatibility information:</div><div id="2672" class="line none"> 2672  * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and</div><div id="2673" class="line none"> 2673  * all task notification API functions operated on that value. Replacing the</div><div id="2674" class="line none"> 2674  * single notification value with an array of notification values necessitated a</div><div id="2675" class="line none"> 2675  * new set of API functions that could address specific notifications within the</div><div id="2676" class="line none"> 2676  * array.  xTaskNotifyStateClear() is the original API function, and remains</div><div id="2677" class="line none"> 2677  * backward compatible by always operating on the notification value at index 0</div><div id="2678" class="line none"> 2678  * within the array. Calling xTaskNotifyStateClear() is equivalent to calling</div><div id="2679" class="line none"> 2679  * xTaskNotifyStateClearIndexed() with the uxIndexToNotify parameter set to 0.</div><div id="2680" class="line none"> 2680  *</div><div id="2681" class="line none"> 2681  * @param xTask The handle of the RTOS task that will have a notification state</div><div id="2682" class="line none"> 2682  * cleared.  Set xTask to NULL to clear a notification state in the calling</div><div id="2683" class="line none"> 2683  * task.  To obtain a task's handle create the task using xTaskCreate() and</div><div id="2684" class="line none"> 2684  * make use of the pxCreatedTask parameter, or create the task using</div><div id="2685" class="line none"> 2685  * xTaskCreateStatic() and store the returned value, or use the task's name in</div><div id="2686" class="line none"> 2686  * a call to xTaskGetHandle().</div><div id="2687" class="line none"> 2687  *</div><div id="2688" class="line none"> 2688  * @param uxIndexToClear The index within the target task's array of</div><div id="2689" class="line none"> 2689  * notification values to act upon.  For example, setting uxIndexToClear to 1</div><div id="2690" class="line none"> 2690  * will clear the state of the notification at index 1 within the array.</div><div id="2691" class="line none"> 2691  * uxIndexToClear must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.</div><div id="2692" class="line none"> 2692  * ulTaskNotifyStateClear() does not have this parameter and always acts on the</div><div id="2693" class="line none"> 2693  * notification at index 0.</div><div id="2694" class="line none"> 2694  *</div><div id="2695" class="line none"> 2695  * @return pdTRUE if the task's notification state was set to</div><div id="2696" class="line none"> 2696  * eNotWaitingNotification, otherwise pdFALSE.</div><div id="2697" class="line none"> 2697  *</div><div id="2698" class="line none"> 2698  * \defgroup xTaskNotifyStateClearIndexed xTaskNotifyStateClearIndexed</div><div id="2699" class="line none"> 2699  * \ingroup TaskNotifications</div><div id="2700" class="line none"> 2700  */</div><div id="2701" class="line none"> 2701 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskGenericNotifyStateClear( <a href="task.h.html#87">TaskHandle_t</a> xTask,</div><div id="2702" class="line none"> 2702                                          <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxIndexToClear ) PRIVILEGED_FUNCTION;</div><div id="2703" class="line none"> 2703 #define <a href="task.h.html#2703">xTaskNotifyStateClear</a>( xTask ) \</div><div id="2704" class="line none"> 2704     xTaskGenericNotifyStateClear( ( xTask ), ( <a href="task.h.html#74">tskDEFAULT_INDEX_TO_NOTIFY</a> ) )</div><div id="2705" class="line none"> 2705 #define <a href="task.h.html#2705">xTaskNotifyStateClearIndexed</a>( xTask, uxIndexToClear ) \</div><div id="2706" class="line none"> 2706     xTaskGenericNotifyStateClear( ( xTask ), ( uxIndexToClear ) )</div><div id="2707" class="line none"> 2707 </div><div id="2708" class="line none"> 2708 /**</div><div id="2709" class="line none"> 2709  * task. h</div><div id="2710" class="line none"> 2710  * @code{c}</div><div id="2711" class="line none"> 2711  * uint32_t ulTaskNotifyValueClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToClear, uint32_t ulBitsToClear );</div><div id="2712" class="line none"> 2712  *</div><div id="2713" class="line none"> 2713  * uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear );</div><div id="2714" class="line none"> 2714  * @endcode</div><div id="2715" class="line none"> 2715  *</div><div id="2716" class="line none"> 2716  * See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.</div><div id="2717" class="line none"> 2717  *</div><div id="2718" class="line none"> 2718  * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these</div><div id="2719" class="line none"> 2719  * functions to be available.</div><div id="2720" class="line none"> 2720  *</div><div id="2721" class="line none"> 2721  * Each task has a private array of "notification values" (or 'notifications'),</div><div id="2722" class="line none"> 2722  * each of which is a 32-bit unsigned integer (uint32_t).  The constant</div><div id="2723" class="line none"> 2723  * configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the</div><div id="2724" class="line none"> 2724  * array, and (for backward compatibility) defaults to 1 if left undefined.</div><div id="2725" class="line none"> 2725  * Prior to FreeRTOS V10.4.0 there was only one notification value per task.</div><div id="2726" class="line none"> 2726  *</div><div id="2727" class="line none"> 2727  * ulTaskNotifyValueClearIndexed() clears the bits specified by the</div><div id="2728" class="line none"> 2728  * ulBitsToClear bit mask in the notification value at array index uxIndexToClear</div><div id="2729" class="line none"> 2729  * of the task referenced by xTask.</div><div id="2730" class="line none"> 2730  *</div><div id="2731" class="line none"> 2731  * Backward compatibility information:</div><div id="2732" class="line none"> 2732  * Prior to FreeRTOS V10.4.0 each task had a single "notification value", and</div><div id="2733" class="line none"> 2733  * all task notification API functions operated on that value. Replacing the</div><div id="2734" class="line none"> 2734  * single notification value with an array of notification values necessitated a</div><div id="2735" class="line none"> 2735  * new set of API functions that could address specific notifications within the</div><div id="2736" class="line none"> 2736  * array.  ulTaskNotifyValueClear() is the original API function, and remains</div><div id="2737" class="line none"> 2737  * backward compatible by always operating on the notification value at index 0</div><div id="2738" class="line none"> 2738  * within the array. Calling ulTaskNotifyValueClear() is equivalent to calling</div><div id="2739" class="line none"> 2739  * ulTaskNotifyValueClearIndexed() with the uxIndexToClear parameter set to 0.</div><div id="2740" class="line none"> 2740  *</div><div id="2741" class="line none"> 2741  * @param xTask The handle of the RTOS task that will have bits in one of its</div><div id="2742" class="line none"> 2742  * notification values cleared. Set xTask to NULL to clear bits in a</div><div id="2743" class="line none"> 2743  * notification value of the calling task.  To obtain a task's handle create the</div><div id="2744" class="line none"> 2744  * task using xTaskCreate() and make use of the pxCreatedTask parameter, or</div><div id="2745" class="line none"> 2745  * create the task using xTaskCreateStatic() and store the returned value, or</div><div id="2746" class="line none"> 2746  * use the task's name in a call to xTaskGetHandle().</div><div id="2747" class="line none"> 2747  *</div><div id="2748" class="line none"> 2748  * @param uxIndexToClear The index within the target task's array of</div><div id="2749" class="line none"> 2749  * notification values in which to clear the bits.  uxIndexToClear</div><div id="2750" class="line none"> 2750  * must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.</div><div id="2751" class="line none"> 2751  * ulTaskNotifyValueClear() does not have this parameter and always clears bits</div><div id="2752" class="line none"> 2752  * in the notification value at index 0.</div><div id="2753" class="line none"> 2753  *</div><div id="2754" class="line none"> 2754  * @param ulBitsToClear Bit mask of the bits to clear in the notification value of</div><div id="2755" class="line none"> 2755  * xTask. Set a bit to 1 to clear the corresponding bits in the task's notification</div><div id="2756" class="line none"> 2756  * value. Set ulBitsToClear to 0xffffffff (UINT_MAX on 32-bit architectures) to clear</div><div id="2757" class="line none"> 2757  * the notification value to 0.  Set ulBitsToClear to 0 to query the task's</div><div id="2758" class="line none"> 2758  * notification value without clearing any bits.</div><div id="2759" class="line none"> 2759  *</div><div id="2760" class="line none"> 2760  *</div><div id="2761" class="line none"> 2761  * @return The value of the target task's notification value before the bits</div><div id="2762" class="line none"> 2762  * specified by ulBitsToClear were cleared.</div><div id="2763" class="line none"> 2763  * \defgroup ulTaskNotifyValueClear ulTaskNotifyValueClear</div><div id="2764" class="line none"> 2764  * \ingroup TaskNotifications</div><div id="2765" class="line none"> 2765  */</div><div id="2766" class="line none"> 2766 uint32_t ulTaskGenericNotifyValueClear( <a href="task.h.html#87">TaskHandle_t</a> xTask,</div><div id="2767" class="line none"> 2767                                         <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxIndexToClear,</div><div id="2768" class="line none"> 2768                                         uint32_t ulBitsToClear ) PRIVILEGED_FUNCTION;</div><div id="2769" class="line none"> 2769 #define <a href="task.h.html#2769">ulTaskNotifyValueClear</a>( xTask, ulBitsToClear ) \</div><div id="2770" class="line none"> 2770     ulTaskGenericNotifyValueClear( ( xTask ), ( <a href="task.h.html#74">tskDEFAULT_INDEX_TO_NOTIFY</a> ), ( ulBitsToClear ) )</div><div id="2771" class="line none"> 2771 #define <a href="task.h.html#2771">ulTaskNotifyValueClearIndexed</a>( xTask, uxIndexToClear, ulBitsToClear ) \</div><div id="2772" class="line none"> 2772     ulTaskGenericNotifyValueClear( ( xTask ), ( uxIndexToClear ), ( ulBitsToClear ) )</div><div id="2773" class="line none"> 2773 </div><div id="2774" class="line none"> 2774 /**</div><div id="2775" class="line none"> 2775  * task.h</div><div id="2776" class="line none"> 2776  * @code{c}</div><div id="2777" class="line none"> 2777  * void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut );</div><div id="2778" class="line none"> 2778  * @endcode</div><div id="2779" class="line none"> 2779  *</div><div id="2780" class="line none"> 2780  * Capture the current time for future use with xTaskCheckForTimeOut().</div><div id="2781" class="line none"> 2781  *</div><div id="2782" class="line none"> 2782  * @param pxTimeOut Pointer to a timeout object into which the current time</div><div id="2783" class="line none"> 2783  * is to be captured.  The captured time includes the tick count and the number</div><div id="2784" class="line none"> 2784  * of times the tick count has overflowed since the system first booted.</div><div id="2785" class="line none"> 2785  * \defgroup vTaskSetTimeOutState vTaskSetTimeOutState</div><div id="2786" class="line none"> 2786  * \ingroup TaskCtrl</div><div id="2787" class="line none"> 2787  */</div><div id="2788" class="line none"> 2788 void vTaskSetTimeOutState( <a href="task.h.html#123">TimeOut_t</a> * const pxTimeOut ) PRIVILEGED_FUNCTION;</div><div id="2789" class="line none"> 2789 </div><div id="2790" class="line none"> 2790 /**</div><div id="2791" class="line none"> 2791  * task.h</div><div id="2792" class="line none"> 2792  * @code{c}</div><div id="2793" class="line none"> 2793  * BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait );</div><div id="2794" class="line none"> 2794  * @endcode</div><div id="2795" class="line none"> 2795  *</div><div id="2796" class="line none"> 2796  * Determines if pxTicksToWait ticks has passed since a time was captured</div><div id="2797" class="line none"> 2797  * using a call to vTaskSetTimeOutState().  The captured time includes the tick</div><div id="2798" class="line none"> 2798  * count and the number of times the tick count has overflowed.</div><div id="2799" class="line none"> 2799  *</div><div id="2800" class="line none"> 2800  * @param pxTimeOut The time status as captured previously using</div><div id="2801" class="line none"> 2801  * vTaskSetTimeOutState. If the timeout has not yet occurred, it is updated</div><div id="2802" class="line none"> 2802  * to reflect the current time status.</div><div id="2803" class="line none"> 2803  * @param pxTicksToWait The number of ticks to check for timeout i.e. if</div><div id="2804" class="line none"> 2804  * pxTicksToWait ticks have passed since pxTimeOut was last updated (either by</div><div id="2805" class="line none"> 2805  * vTaskSetTimeOutState() or xTaskCheckForTimeOut()), the timeout has occurred.</div><div id="2806" class="line none"> 2806  * If the timeout has not occurred, pxTicksToWait is updated to reflect the</div><div id="2807" class="line none"> 2807  * number of remaining ticks.</div><div id="2808" class="line none"> 2808  *</div><div id="2809" class="line none"> 2809  * @return If timeout has occurred, pdTRUE is returned. Otherwise pdFALSE is</div><div id="2810" class="line none"> 2810  * returned and pxTicksToWait is updated to reflect the number of remaining</div><div id="2811" class="line none"> 2811  * ticks.</div><div id="2812" class="line none"> 2812  *</div><div id="2813" class="line none"> 2813  * @see https://www.FreeRTOS.org/xTaskCheckForTimeOut.html</div><div id="2814" class="line none"> 2814  *</div><div id="2815" class="line none"> 2815  * Example Usage:</div><div id="2816" class="line none"> 2816  * @code{c}</div><div id="2817" class="line none"> 2817  *  // Driver library function used to receive uxWantedBytes from an Rx buffer</div><div id="2818" class="line none"> 2818  *  // that is filled by a UART interrupt. If there are not enough bytes in the</div><div id="2819" class="line none"> 2819  *  // Rx buffer then the task enters the Blocked state until it is notified that</div><div id="2820" class="line none"> 2820  *  // more data has been placed into the buffer. If there is still not enough</div><div id="2821" class="line none"> 2821  *  // data then the task re-enters the Blocked state, and xTaskCheckForTimeOut()</div><div id="2822" class="line none"> 2822  *  // is used to re-calculate the Block time to ensure the total amount of time</div><div id="2823" class="line none"> 2823  *  // spent in the Blocked state does not exceed MAX_TIME_TO_WAIT. This</div><div id="2824" class="line none"> 2824  *  // continues until either the buffer contains at least uxWantedBytes bytes,</div><div id="2825" class="line none"> 2825  *  // or the total amount of time spent in the Blocked state reaches</div><div id="2826" class="line none"> 2826  *  // MAX_TIME_TO_WAIT - at which point the task reads however many bytes are</div><div id="2827" class="line none"> 2827  *  // available up to a maximum of uxWantedBytes.</div><div id="2828" class="line none"> 2828  *</div><div id="2829" class="line none"> 2829  *  size_t xUART_Receive( uint8_t *pucBuffer, size_t uxWantedBytes )</div><div id="2830" class="line none"> 2830  *  {</div><div id="2831" class="line none"> 2831  *  size_t uxReceived = 0;</div><div id="2832" class="line none"> 2832  *  TickType_t xTicksToWait = MAX_TIME_TO_WAIT;</div><div id="2833" class="line none"> 2833  *  TimeOut_t xTimeOut;</div><div id="2834" class="line none"> 2834  *</div><div id="2835" class="line none"> 2835  *      // Initialize xTimeOut.  This records the time at which this function</div><div id="2836" class="line none"> 2836  *      // was entered.</div><div id="2837" class="line none"> 2837  *      vTaskSetTimeOutState( &amp;xTimeOut );</div><div id="2838" class="line none"> 2838  *</div><div id="2839" class="line none"> 2839  *      // Loop until the buffer contains the wanted number of bytes, or a</div><div id="2840" class="line none"> 2840  *      // timeout occurs.</div><div id="2841" class="line none"> 2841  *      while( UART_bytes_in_rx_buffer( pxUARTInstance ) &lt; uxWantedBytes )</div><div id="2842" class="line none"> 2842  *      {</div><div id="2843" class="line none"> 2843  *          // The buffer didn't contain enough data so this task is going to</div><div id="2844" class="line none"> 2844  *          // enter the Blocked state. Adjusting xTicksToWait to account for</div><div id="2845" class="line none"> 2845  *          // any time that has been spent in the Blocked state within this</div><div id="2846" class="line none"> 2846  *          // function so far to ensure the total amount of time spent in the</div><div id="2847" class="line none"> 2847  *          // Blocked state does not exceed MAX_TIME_TO_WAIT.</div><div id="2848" class="line none"> 2848  *          if( xTaskCheckForTimeOut( &amp;xTimeOut, &amp;xTicksToWait ) != pdFALSE )</div><div id="2849" class="line none"> 2849  *          {</div><div id="2850" class="line none"> 2850  *              //Timed out before the wanted number of bytes were available,</div><div id="2851" class="line none"> 2851  *              // exit the loop.</div><div id="2852" class="line none"> 2852  *              break;</div><div id="2853" class="line none"> 2853  *          }</div><div id="2854" class="line none"> 2854  *</div><div id="2855" class="line none"> 2855  *          // Wait for a maximum of xTicksToWait ticks to be notified that the</div><div id="2856" class="line none"> 2856  *          // receive interrupt has placed more data into the buffer.</div><div id="2857" class="line none"> 2857  *          ulTaskNotifyTake( pdTRUE, xTicksToWait );</div><div id="2858" class="line none"> 2858  *      }</div><div id="2859" class="line none"> 2859  *</div><div id="2860" class="line none"> 2860  *      // Attempt to read uxWantedBytes from the receive buffer into pucBuffer.</div><div id="2861" class="line none"> 2861  *      // The actual number of bytes read (which might be less than</div><div id="2862" class="line none"> 2862  *      // uxWantedBytes) is returned.</div><div id="2863" class="line none"> 2863  *      uxReceived = UART_read_from_receive_buffer( pxUARTInstance,</div><div id="2864" class="line none"> 2864  *                                                  pucBuffer,</div><div id="2865" class="line none"> 2865  *                                                  uxWantedBytes );</div><div id="2866" class="line none"> 2866  *</div><div id="2867" class="line none"> 2867  *      return uxReceived;</div><div id="2868" class="line none"> 2868  *  }</div><div id="2869" class="line none"> 2869  * @endcode</div><div id="2870" class="line none"> 2870  * \defgroup xTaskCheckForTimeOut xTaskCheckForTimeOut</div><div id="2871" class="line none"> 2871  * \ingroup TaskCtrl</div><div id="2872" class="line none"> 2872  */</div><div id="2873" class="line none"> 2873 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskCheckForTimeOut( <a href="task.h.html#123">TimeOut_t</a> * const pxTimeOut,</div><div id="2874" class="line none"> 2874                                  <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> * const pxTicksToWait ) PRIVILEGED_FUNCTION;</div><div id="2875" class="line none"> 2875 </div><div id="2876" class="line none"> 2876 /**</div><div id="2877" class="line none"> 2877  * task.h</div><div id="2878" class="line none"> 2878  * @code{c}</div><div id="2879" class="line none"> 2879  * BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp );</div><div id="2880" class="line none"> 2880  * @endcode</div><div id="2881" class="line none"> 2881  *</div><div id="2882" class="line none"> 2882  * This function corrects the tick count value after the application code has held</div><div id="2883" class="line none"> 2883  * interrupts disabled for an extended period resulting in tick interrupts having</div><div id="2884" class="line none"> 2884  * been missed.</div><div id="2885" class="line none"> 2885  *</div><div id="2886" class="line none"> 2886  * This function is similar to vTaskStepTick(), however, unlike</div><div id="2887" class="line none"> 2887  * vTaskStepTick(), xTaskCatchUpTicks() may move the tick count forward past a</div><div id="2888" class="line none"> 2888  * time at which a task should be removed from the blocked state.  That means</div><div id="2889" class="line none"> 2889  * tasks may have to be removed from the blocked state as the tick count is</div><div id="2890" class="line none"> 2890  * moved.</div><div id="2891" class="line none"> 2891  *</div><div id="2892" class="line none"> 2892  * @param xTicksToCatchUp The number of tick interrupts that have been missed due to</div><div id="2893" class="line none"> 2893  * interrupts being disabled.  Its value is not computed automatically, so must be</div><div id="2894" class="line none"> 2894  * computed by the application writer.</div><div id="2895" class="line none"> 2895  *</div><div id="2896" class="line none"> 2896  * @return pdTRUE if moving the tick count forward resulted in a task leaving the</div><div id="2897" class="line none"> 2897  * blocked state and a context switch being performed.  Otherwise pdFALSE.</div><div id="2898" class="line none"> 2898  *</div><div id="2899" class="line none"> 2899  * \defgroup xTaskCatchUpTicks xTaskCatchUpTicks</div><div id="2900" class="line none"> 2900  * \ingroup TaskCtrl</div><div id="2901" class="line none"> 2901  */</div><div id="2902" class="line none"> 2902 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskCatchUpTicks( <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> xTicksToCatchUp ) PRIVILEGED_FUNCTION;</div><div id="2903" class="line none"> 2903 </div><div id="2904" class="line none"> 2904 </div><div id="2905" class="line none"> 2905 /*-----------------------------------------------------------</div><div id="2906" class="line none"> 2906 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES</div><div id="2907" class="line none"> 2907 *----------------------------------------------------------*/</div><div id="2908" class="line none"> 2908 </div><div id="2909" class="line none"> 2909 /*</div><div id="2910" class="line none"> 2910  * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY</div><div id="2911" class="line none"> 2911  * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS</div><div id="2912" class="line none"> 2912  * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.</div><div id="2913" class="line none"> 2913  *</div><div id="2914" class="line none"> 2914  * Called from the real time kernel tick (either preemptive or cooperative),</div><div id="2915" class="line none"> 2915  * this increments the tick count and checks if any tasks that are blocked</div><div id="2916" class="line none"> 2916  * for a finite period required removing from a blocked list and placing on</div><div id="2917" class="line none"> 2917  * a ready list.  If a non-zero value is returned then a context switch is</div><div id="2918" class="line none"> 2918  * required because either:</div><div id="2919" class="line none"> 2919  *   + A task was removed from a blocked list because its timeout had expired,</div><div id="2920" class="line none"> 2920  *     or</div><div id="2921" class="line none"> 2921  *   + Time slicing is in use and there is a task of equal priority to the</div><div id="2922" class="line none"> 2922  *     currently running task.</div><div id="2923" class="line none"> 2923  */</div><div id="2924" class="line none"> 2924 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;</div><div id="2925" class="line none"> 2925 </div><div id="2926" class="line none"> 2926 /*</div><div id="2927" class="line none"> 2927  * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN</div><div id="2928" class="line none"> 2928  * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.</div><div id="2929" class="line none"> 2929  *</div><div id="2930" class="line none"> 2930  * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.</div><div id="2931" class="line none"> 2931  *</div><div id="2932" class="line none"> 2932  * Removes the calling task from the ready list and places it both</div><div id="2933" class="line none"> 2933  * on the list of tasks waiting for a particular event, and the</div><div id="2934" class="line none"> 2934  * list of delayed tasks.  The task will be removed from both lists</div><div id="2935" class="line none"> 2935  * and replaced on the ready list should either the event occur (and</div><div id="2936" class="line none"> 2936  * there be no higher priority tasks waiting on the same event) or</div><div id="2937" class="line none"> 2937  * the delay period expires.</div><div id="2938" class="line none"> 2938  *</div><div id="2939" class="line none"> 2939  * The 'unordered' version replaces the event list item value with the</div><div id="2940" class="line none"> 2940  * xItemValue value, and inserts the list item at the end of the list.</div><div id="2941" class="line none"> 2941  *</div><div id="2942" class="line none"> 2942  * The 'ordered' version uses the existing event list item value (which is the</div><div id="2943" class="line none"> 2943  * owning task's priority) to insert the list item into the event list in task</div><div id="2944" class="line none"> 2944  * priority order.</div><div id="2945" class="line none"> 2945  *</div><div id="2946" class="line none"> 2946  * @param pxEventList The list containing tasks that are blocked waiting</div><div id="2947" class="line none"> 2947  * for the event to occur.</div><div id="2948" class="line none"> 2948  *</div><div id="2949" class="line none"> 2949  * @param xItemValue The item value to use for the event list item when the</div><div id="2950" class="line none"> 2950  * event list is not ordered by task priority.</div><div id="2951" class="line none"> 2951  *</div><div id="2952" class="line none"> 2952  * @param xTicksToWait The maximum amount of time that the task should wait</div><div id="2953" class="line none"> 2953  * for the event to occur.  This is specified in kernel ticks, the constant</div><div id="2954" class="line none"> 2954  * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time</div><div id="2955" class="line none"> 2955  * period.</div><div id="2956" class="line none"> 2956  */</div><div id="2957" class="line none"> 2957 void vTaskPlaceOnEventList( List_t * const pxEventList,</div><div id="2958" class="line none"> 2958                             const <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> xTicksToWait ) PRIVILEGED_FUNCTION;</div><div id="2959" class="line none"> 2959 void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,</div><div id="2960" class="line none"> 2960                                      const <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> xItemValue,</div><div id="2961" class="line none"> 2961                                      const <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> xTicksToWait ) PRIVILEGED_FUNCTION;</div><div id="2962" class="line none"> 2962 </div><div id="2963" class="line none"> 2963 /*</div><div id="2964" class="line none"> 2964  * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN</div><div id="2965" class="line none"> 2965  * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.</div><div id="2966" class="line none"> 2966  *</div><div id="2967" class="line none"> 2967  * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.</div><div id="2968" class="line none"> 2968  *</div><div id="2969" class="line none"> 2969  * This function performs nearly the same function as vTaskPlaceOnEventList().</div><div id="2970" class="line none"> 2970  * The difference being that this function does not permit tasks to block</div><div id="2971" class="line none"> 2971  * indefinitely, whereas vTaskPlaceOnEventList() does.</div><div id="2972" class="line none"> 2972  *</div><div id="2973" class="line none"> 2973  */</div><div id="2974" class="line none"> 2974 void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,</div><div id="2975" class="line none"> 2975                                       <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> xTicksToWait,</div><div id="2976" class="line none"> 2976                                       const <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xWaitIndefinitely ) PRIVILEGED_FUNCTION;</div><div id="2977" class="line none"> 2977 </div><div id="2978" class="line none"> 2978 /*</div><div id="2979" class="line none"> 2979  * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN</div><div id="2980" class="line none"> 2980  * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.</div><div id="2981" class="line none"> 2981  *</div><div id="2982" class="line none"> 2982  * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.</div><div id="2983" class="line none"> 2983  *</div><div id="2984" class="line none"> 2984  * Removes a task from both the specified event list and the list of blocked</div><div id="2985" class="line none"> 2985  * tasks, and places it on a ready queue.</div><div id="2986" class="line none"> 2986  *</div><div id="2987" class="line none"> 2987  * xTaskRemoveFromEventList()/vTaskRemoveFromUnorderedEventList() will be called</div><div id="2988" class="line none"> 2988  * if either an event occurs to unblock a task, or the block timeout period</div><div id="2989" class="line none"> 2989  * expires.</div><div id="2990" class="line none"> 2990  *</div><div id="2991" class="line none"> 2991  * xTaskRemoveFromEventList() is used when the event list is in task priority</div><div id="2992" class="line none"> 2992  * order.  It removes the list item from the head of the event list as that will</div><div id="2993" class="line none"> 2993  * have the highest priority owning task of all the tasks on the event list.</div><div id="2994" class="line none"> 2994  * vTaskRemoveFromUnorderedEventList() is used when the event list is not</div><div id="2995" class="line none"> 2995  * ordered and the event list items hold something other than the owning tasks</div><div id="2996" class="line none"> 2996  * priority.  In this case the event list item value is updated to the value</div><div id="2997" class="line none"> 2997  * passed in the xItemValue parameter.</div><div id="2998" class="line none"> 2998  *</div><div id="2999" class="line none"> 2999  * @return pdTRUE if the task being removed has a higher priority than the task</div><div id="3000" class="line none"> 3000  * making the call, otherwise pdFALSE.</div><div id="3001" class="line none"> 3001  */</div><div id="3002" class="line none"> 3002 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;</div><div id="3003" class="line none"> 3003 void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,</div><div id="3004" class="line none"> 3004                                         const <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> xItemValue ) PRIVILEGED_FUNCTION;</div><div id="3005" class="line none"> 3005 </div><div id="3006" class="line none"> 3006 /*</div><div id="3007" class="line none"> 3007  * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY</div><div id="3008" class="line none"> 3008  * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS</div><div id="3009" class="line none"> 3009  * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.</div><div id="3010" class="line none"> 3010  *</div><div id="3011" class="line none"> 3011  * Sets the pointer to the current TCB to the TCB of the highest priority task</div><div id="3012" class="line none"> 3012  * that is ready to run.</div><div id="3013" class="line none"> 3013  */</div><div id="3014" class="line none"> 3014 portDONT_DISCARD void vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;</div><div id="3015" class="line none"> 3015 </div><div id="3016" class="line none"> 3016 /*</div><div id="3017" class="line none"> 3017  * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY</div><div id="3018" class="line none"> 3018  * THE EVENT BITS MODULE.</div><div id="3019" class="line none"> 3019  */</div><div id="3020" class="line none"> 3020 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;</div><div id="3021" class="line none"> 3021 </div><div id="3022" class="line none"> 3022 /*</div><div id="3023" class="line none"> 3023  * Return the handle of the calling task.</div><div id="3024" class="line none"> 3024  */</div><div id="3025" class="line none"> 3025 <a href="task.h.html#87">TaskHandle_t</a> xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;</div><div id="3026" class="line none"> 3026 </div><div id="3027" class="line none"> 3027 /*</div><div id="3028" class="line none"> 3028  * Shortcut used by the queue implementation to prevent unnecessary call to</div><div id="3029" class="line none"> 3029  * taskYIELD();</div><div id="3030" class="line none"> 3030  */</div><div id="3031" class="line none"> 3031 void vTaskMissedYield( void ) PRIVILEGED_FUNCTION;</div><div id="3032" class="line none"> 3032 </div><div id="3033" class="line none"> 3033 /*</div><div id="3034" class="line none"> 3034  * Returns the scheduler state as taskSCHEDULER_RUNNING,</div><div id="3035" class="line none"> 3035  * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.</div><div id="3036" class="line none"> 3036  */</div><div id="3037" class="line none"> 3037 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;</div><div id="3038" class="line none"> 3038 </div><div id="3039" class="line none"> 3039 /*</div><div id="3040" class="line none"> 3040  * Raises the priority of the mutex holder to that of the calling task should</div><div id="3041" class="line none"> 3041  * the mutex holder have a priority less than the calling task.</div><div id="3042" class="line none"> 3042  */</div><div id="3043" class="line none"> 3043 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskPriorityInherit( <a href="task.h.html#87">TaskHandle_t</a> const pxMutexHolder ) PRIVILEGED_FUNCTION;</div><div id="3044" class="line none"> 3044 </div><div id="3045" class="line none"> 3045 /*</div><div id="3046" class="line none"> 3046  * Set the priority of a task back to its proper priority in the case that it</div><div id="3047" class="line none"> 3047  * inherited a higher priority while it was holding a semaphore.</div><div id="3048" class="line none"> 3048  */</div><div id="3049" class="line none"> 3049 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#60">BaseType_t</a> xTaskPriorityDisinherit( <a href="task.h.html#87">TaskHandle_t</a> const pxMutexHolder ) PRIVILEGED_FUNCTION;</div><div id="3050" class="line none"> 3050 </div><div id="3051" class="line none"> 3051 /*</div><div id="3052" class="line none"> 3052  * If a higher priority task attempting to obtain a mutex caused a lower</div><div id="3053" class="line none"> 3053  * priority task to inherit the higher priority task's priority - but the higher</div><div id="3054" class="line none"> 3054  * priority task then timed out without obtaining the mutex, then the lower</div><div id="3055" class="line none"> 3055  * priority task will disinherit the priority again - but only down as far as</div><div id="3056" class="line none"> 3056  * the highest priority task that is still waiting for the mutex (if there were</div><div id="3057" class="line none"> 3057  * more than one task waiting for the mutex).</div><div id="3058" class="line none"> 3058  */</div><div id="3059" class="line none"> 3059 void vTaskPriorityDisinheritAfterTimeout( <a href="task.h.html#87">TaskHandle_t</a> const pxMutexHolder,</div><div id="3060" class="line none"> 3060                                           <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxHighestPriorityWaitingTask ) PRIVILEGED_FUNCTION;</div><div id="3061" class="line none"> 3061 </div><div id="3062" class="line none"> 3062 /*</div><div id="3063" class="line none"> 3063  * Get the uxTaskNumber assigned to the task referenced by the xTask parameter.</div><div id="3064" class="line none"> 3064  */</div><div id="3065" class="line none"> 3065 <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxTaskGetTaskNumber( <a href="task.h.html#87">TaskHandle_t</a> xTask ) PRIVILEGED_FUNCTION;</div><div id="3066" class="line none"> 3066 </div><div id="3067" class="line none"> 3067 /*</div><div id="3068" class="line none"> 3068  * Set the uxTaskNumber of the task referenced by the xTask parameter to</div><div id="3069" class="line none"> 3069  * uxHandle.</div><div id="3070" class="line none"> 3070  */</div><div id="3071" class="line none"> 3071 void vTaskSetTaskNumber( <a href="task.h.html#87">TaskHandle_t</a> xTask,</div><div id="3072" class="line none"> 3072                          const <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#61">UBaseType_t</a> uxHandle ) PRIVILEGED_FUNCTION;</div><div id="3073" class="line none"> 3073 </div><div id="3074" class="line none"> 3074 /*</div><div id="3075" class="line none"> 3075  * Only available when configUSE_TICKLESS_IDLE is set to 1.</div><div id="3076" class="line none"> 3076  * If tickless mode is being used, or a low power mode is implemented, then</div><div id="3077" class="line none"> 3077  * the tick interrupt will not execute during idle periods.  When this is the</div><div id="3078" class="line none"> 3078  * case, the tick count value maintained by the scheduler needs to be kept up</div><div id="3079" class="line none"> 3079  * to date with the actual execution time by being skipped forward by a time</div><div id="3080" class="line none"> 3080  * equal to the idle period.</div><div id="3081" class="line none"> 3081  */</div><div id="3082" class="line none"> 3082 void vTaskStepTick( <a href="../portable/ThirdParty/GCC/Posix/portmacro.h.html#63">TickType_t</a> xTicksToJump ) PRIVILEGED_FUNCTION;</div><div id="3083" class="line none"> 3083 </div><div id="3084" class="line none"> 3084 /*</div><div id="3085" class="line none"> 3085  * Only available when configUSE_TICKLESS_IDLE is set to 1.</div><div id="3086" class="line none"> 3086  * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port</div><div id="3087" class="line none"> 3087  * specific sleep function to determine if it is ok to proceed with the sleep,</div><div id="3088" class="line none"> 3088  * and if it is ok to proceed, if it is ok to sleep indefinitely.</div><div id="3089" class="line none"> 3089  *</div><div id="3090" class="line none"> 3090  * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only</div><div id="3091" class="line none"> 3091  * called with the scheduler suspended, not from within a critical section.  It</div><div id="3092" class="line none"> 3092  * is therefore possible for an interrupt to request a context switch between</div><div id="3093" class="line none"> 3093  * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being</div><div id="3094" class="line none"> 3094  * entered.  eTaskConfirmSleepModeStatus() should be called from a short</div><div id="3095" class="line none"> 3095  * critical section between the timer being stopped and the sleep mode being</div><div id="3096" class="line none"> 3096  * entered to ensure it is ok to proceed into the sleep mode.</div><div id="3097" class="line none"> 3097  */</div><div id="3098" class="line none"> 3098 <a href="task.h.html#179">eSleepModeStatus</a> eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;</div><div id="3099" class="line none"> 3099 </div><div id="3100" class="line none"> 3100 /*</div><div id="3101" class="line none"> 3101  * For internal use only.  Increment the mutex held count when a mutex is</div><div id="3102" class="line none"> 3102  * taken and return the handle of the task that has taken the mutex.</div><div id="3103" class="line none"> 3103  */</div><div id="3104" class="line none"> 3104 <a href="task.h.html#87">TaskHandle_t</a> pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;</div><div id="3105" class="line none"> 3105 </div><div id="3106" class="line none"> 3106 /*</div><div id="3107" class="line none"> 3107  * For internal use only.  Same as vTaskSetTimeOutState(), but without a critical</div><div id="3108" class="line none"> 3108  * section.</div><div id="3109" class="line none"> 3109  */</div><div id="3110" class="line none"> 3110 void vTaskInternalSetTimeOutState( <a href="task.h.html#123">TimeOut_t</a> * const pxTimeOut ) PRIVILEGED_FUNCTION;</div><div id="3111" class="line none"> 3111 </div><div id="3112" class="line none"> 3112 </div><div id="3113" class="line none"> 3113 /* *INDENT-OFF* */</div><div id="3114" class="line none"> 3114 #ifdef __cplusplus</div><div id="3115" class="line none"> 3115     }</div><div id="3116" class="line none"> 3116 #endif</div><div id="3117" class="line none"> 3117 /* *INDENT-ON* */</div><div id="3118" class="line none"> 3118 #endif /* INC_TASK_H */</div>
</div>
</body>
</html>
